<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BFC VIP</title>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      padding: 20px;
      margin: 0;
      background-color: #f4f6f8;
      color: #222;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 28px;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: auto;
      background: white;
      padding: 1rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: #fff;
      transition: background 0.3s;
    }
    button:hover {
      filter: brightness(85%);
    }
    .player { background-color: #2196F3; }
    .banker { background-color: #E91E63; }
    .clear-all { background-color: #dc3545; }
    .set-bet, .reset-bet, .mm-action {
      background-color: #6c757d;
    }
    .toggle-section {
      background-color: #6c757d;
      padding: 8px;
      width: 100%;
      text-align: center;
    }
    .collapsible {
      display: none;
    }
    .collapsible.show {
      display: flex;
    }
    .prediction {
      font-weight: bold;
      font-size: 1.2rem;
      text-align: center;
      margin-top: 1rem;
    }
    .shoe-type {
      text-align: center;
      font-size: 1rem;
      margin-top: 0.5rem;
      color: #555;
    }
    .history {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .history div {
      width: 40px;
      height: 30px;
      margin: 3px;
      line-height: 30px;
      text-align: center;
      color: white;
      font-weight: bold;
      border-radius: 5px;
      position: relative;
    }
    .P { background-color: #2196F3; }
    .B { background-color: #E91E63; }
    .W::after, .L::after {
      content: attr(data-outcome);
      position: absolute;
      top: -10px;
      right: -5px;
      font-size: 12px;
      color: #fff;
      background: #28a745;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
    }
    .L::after {
      background: #dc3545;
    }
    .stats {
      padding: 15px;
      text-align: center;
    }
    .section {
      text-align: center;
      margin: 12px 0;
      font-size: 18px;
      font-weight: 700;
    }
    .bet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      margin-bottom: 1rem;
      width: 100%;
      max-width: 90vw;
    }
    input[type=number], select {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      width: 150px;
    }
    label {
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .cycle-reset {
      color: #28a745;
      font-weight: 700;
    }
    @media (max-width: 500px) {
      .flex-row { flex-direction: column; align-items: stretch; }
      .bet-controls { flex-direction: column; align-items: stretch; }
      input[type=number], select { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>BFC VIP</h1>

    <div class="flex-row">
      <button class="player" onclick="recordResult('P')" aria-label="Record Player result">Player</button>
      <button class="banker" onclick="recordResult('B')" aria-label="Record Banker result">Banker</button>
      <button class="clear-all" onclick="clearAll()" aria-label="Clear all data">Clear All</button>
      <button class="undo" onclick="undo()" aria-label="Undo last action">Undo</button>
    </div>

    <div class="prediction" id="prediction">Waiting for input...</div>
    <div class="shoe-type" id="shoeType">Detected Pattern: N/A</div>
    <div class="history" id="historyDisplay"></div>

    <div class="stats">
      <div class="section" id="currentWager">üíµ Current Bet: 0</div>
      <div class="section" id="bankrollDisplay">üíº Balance: - | Profit: -</div>
      <div class="section" id="streakInfo"></div>
      <div class="section">
        ‚úÖ <span id="wins">0</span> | ‚ùå <span id="losses">0</span> | üìä <span id="accuracy">0%</span>
      </div>
      <div class="bet-controls">
        <label><span>Bankroll</span><input type="number" id="bankrollInput" placeholder="Bankroll" min="0.01" step="0.01" aria-label="Set bankroll"></label>
        <label><span>Unit Value</span><input type="number" id="basebetInput" placeholder="Unit Value ($)" min="0.01" step="0.01" aria-label="Set base unit"></label>
        <label>
          <select id="stopProfitType" aria-label="Select stop profit type">
            <option value="currency">$</option>
            <option value="percentage">%</option>
          </select>
          <input type="number" id="stopProfitInput" placeholder="Stop Profit" min="0" step="0.01" aria-label="Set stop profit">
        </label>
        <button class="set-bet" onclick="setBankroll()" aria-label="Set bankroll and bet">Set</button>
      </div>
      <button class="toggle-section" onclick="toggleAdvanced()" aria-label="Toggle advanced controls">Show Advanced</button>
      <div class="flex-row collapsible" id="advancedControls">
        <button class="reset-bet" onclick="resetBet()" aria-label="Reset bet">Reset Bet</button>
        <button class="mm-action" onclick="saveMemory()" aria-label="Save state">üíæ</button>
        <button class="mm-action" onclick="loadMemory()" aria-label="Load state">üì•</button>
      </div>
    </div>
  </div>

  <script>
    // ---- State Management ----
    let state = {
      history: [],
      outcomes: [],
      wins: 0,
      losses: 0,
      baseUnit: 0,
      startBankroll: 0,
      currentBankroll: 0,
      betState: { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] },
      stopProfitType: 'percentage',
      stopProfitValue: 0,
      stopProfitEffective: 0,
      stopProfitReached: false
    };
    let snapshots = [];
    let saveTimeout = null;

    function getCurrentPrediction() {
      if (state.history.length < 5) return null;

      const last5 = state.history.slice(-5);
      const countB = last5.filter(x => x === 'B').length;
      const countP = last5.filter(x => x === 'P').length;

      if (last5.every((v, i, a) => i === 0 || v !== a[i - 1])) {
        return last5.at(-1) === 'B' ? 'P' : 'B';
      } else if (last5.slice(-3).every(v => v === last5.at(-1))) {
        return last5.at(-1);
      } else if (countB === 4 || countP === 4) {
        return countB > countP ? 'P' : 'B';
      } else {
        return state.history.slice(-3).filter(x => x === 'B').length < 2 ? 'B' : 'P';
      }
    }

    function recordResult(result) {
      if (!state.baseUnit || !state.startBankroll) {
        alert('Set bankroll/unit first');
        return;
      }

      const prediction = getCurrentPrediction();
      snapshots.push(JSON.parse(JSON.stringify(state)));

      if (!prediction) {
        state.history.push(result);
        alert('No prediction available yet (need 5 hands). No wager placed.');
        saveMemoryFast();
        updateDisplay();
        return;
      }

      if (state.stopProfitReached) {
        alert('Stop profit reached');
        return;
      }
      const wager = getWager();
      if (wager > state.currentBankroll) {
        alert('Insufficient balance');
        return;
      }

      state.history.push(result);
      const outcome = result === prediction ? 'win' : 'loss';
      state.outcomes.push(outcome === 'win' ? 'W' : 'L');
      if (outcome === 'win') {
        handleWin();
        state.wins++;
      } else {
        handleLoss();
        state.losses++;
      }
      if (state.stopProfitEffective > 0 && state.currentBankroll - state.startBankroll >= state.stopProfitEffective) {
        state.stopProfitReached = true;
      }
      saveMemoryFast();
      updateDisplay();
    }

    function undo() {
      if (snapshots.length) {
        state = snapshots.pop();
        saveMemoryFast();
        updateDisplay();
      }
    }

    function clearAll() {
      if (confirm('Reset all data?')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.history = [];
        state.outcomes = [];
        state.wins = 0;
        state.losses = 0;
        saveMemoryFast();
        document.getElementById('prediction').innerText = 'Waiting for input...';
        document.getElementById('shoeType').innerText = 'Detected Pattern: N/A';
        document.getElementById('historyDisplay').innerHTML = '';
        updateMMDisplay();
      }
    }

    function setBankroll() {
      const bankroll = parseFloat(document.getElementById('bankrollInput').value);
      const unit = parseFloat(document.getElementById('basebetInput').value);
      const stopProfit = parseFloat(document.getElementById('stopProfitInput').value) || 0;
      state.stopProfitType = document.getElementById('stopProfitType').value;

      if (isNaN(bankroll) || bankroll <= 0 || isNaN(unit) || unit <= 0) {
        alert('Invalid bankroll or unit value');
        return;
      }
      if (stopProfit < 0) {
        alert('Invalid stop profit');
        return;
      }

      snapshots.push(JSON.parse(JSON.stringify(state)));
      state.startBankroll = bankroll;
      state.baseUnit = unit;
      state.currentBankroll = bankroll;
      state.stopProfitValue = stopProfit;
      state.stopProfitEffective = state.stopProfitType === 'percentage' ? stopProfit / 100 * bankroll : stopProfit;
      state.stopProfitReached = false;
      state.betState = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
      state.wins = 0;
      state.losses = 0;
      state.outcomes = [];
      saveMemoryFast();
      updateMMDisplay();
    }

    function handleWin() {
      const wager = state.baseUnit * state.betState.currentBetUnits;
      state.betState.totalProfit += state.betState.currentBetUnits;
      state.betState.cycleProfit += state.betState.currentBetUnits;
      state.currentBankroll += wager;
      if (state.betState.cycleProfit >= 1) {
        state.betState.currentBetUnits = 1;
        state.betState.cycleProfit = 0;
        state.betState.previousLosses = [];
      } else {
        if (state.betState.previousLosses.length > 0) {
          state.betState.previousLosses.pop();
        }
        const lastLoss = state.betState.previousLosses.length > 0 ? state.betState.previousLosses[state.betState.previousLosses.length - 1] : 1;
        state.betState.currentBetUnits = lastLoss + 1;
      }
    }

    function handleLoss() {
      const wager = state.baseUnit * state.betState.currentBetUnits;
      state.betState.totalProfit -= state.betState.currentBetUnits;
      state.betState.cycleProfit -= state.betState.currentBetUnits;
      state.betState.previousLosses.push(state.betState.currentBetUnits);
      state.currentBankroll -= wager;
    }

    function resetBet() {
      if (confirm('Reset bet?')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.betState = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
        saveMemoryFast();
        updateMMDisplay();
      }
    }

    function getWager() {
      if (!state.baseUnit || state.stopProfitReached) return 0;
      return Math.min(state.betState.currentBetUnits * state.baseUnit, state.currentBankroll);
    }

    function updateDisplay() {
      updatePrediction();
      updateMMDisplay();
    }

    function updatePrediction() {
      const predDiv = document.getElementById('prediction');
      const shoeDiv = document.getElementById('shoeType');
      const historyDiv = document.getElementById('historyDisplay');

      historyDiv.innerHTML = '';
      state.history.forEach((item, index) => {
        const cell = document.createElement('div');
        cell.innerText = item;
        cell.className = item;
        if (state.outcomes[index]) {
          cell.classList.add(state.outcomes[index]);
          cell.setAttribute('data-outcome', state.outcomes[index]);
        }
        historyDiv.appendChild(cell);
      });

      const prediction = getCurrentPrediction();
      if (!prediction) {
        predDiv.innerText = 'Waiting for more hands...';
        shoeDiv.innerText = 'Detected Pattern: N/A';
        return;
      }

      const last5 = state.history.slice(-5);
      const countB = last5.filter(x => x === 'B').length;
      const countP = last5.filter(x => x === 'P').length;

      let explanation = '';
      if (last5.every((v, i, a) => i === 0 || v !== a[i - 1])) {
        explanation = 'Zigzag breaker detected.';
      } else if (last5.slice(-3).every(v => v === last5.at(-1))) {
        explanation = 'Streak detected.';
      } else if (countB === 4 || countP === 4) {
        explanation = 'Dominance detected in last 5.';
      } else {
        explanation = 'Underdog fallback.';
      }

      predDiv.innerText = `Prediction: ${prediction} (${explanation})`;

      let streaks = 0;
      for (let i = 1; i < state.history.length; i++) {
        if (state.history[i] === state.history[i - 1]) streaks++;
      }
      const chopScore = state.history.length > 1 ? state.history.length - 1 - streaks : 0;
      const chopRatio = state.history.length > 1 ? chopScore / (state.history.length - 1) : 0;

      let pattern = 'Balanced';
      if (chopRatio > 0.7) pattern = 'Chop';
      else if (chopRatio < 0.3) pattern = 'Streak';

      shoeDiv.innerText = `Detected Pattern: ${pattern}`;
    }

    function updateMMDisplay() {
      document.getElementById('streakInfo').innerText = state.stopProfitReached ? '' : 
        state.outcomes.slice(-3).every(v => v === 'L') ? `üßä Cold Streak - Losses: ${state.betState.previousLosses.length}` :
        state.outcomes.slice(-3).every(v => v === 'W') ? `üî• Hot Streak` : '';
      document.getElementById('currentWager').innerText = `üíµ Current Bet: ${getWager().toFixed(2)}`;
      document.getElementById('wins').innerText = state.wins;
      document.getElementById('losses').innerText = state.losses;
      document.getElementById('accuracy').innerText = state.wins + state.losses ? ((state.wins / (state.wins + state.losses)) * 100).toFixed(1) + '%' : '0%';
      const previousLosses = state.betState.previousLosses.length > 0 ? state.betState.previousLosses.join(', ') : 'None';
      const stopProfitDisplay = state.stopProfitValue > 0 ? 
        state.stopProfitType === 'percentage' ? `${state.stopProfitValue}% ($${state.stopProfitEffective.toFixed(2)})` : 
        `$${state.stopProfitValue.toFixed(2)}` : 'Not Set';
      document.getElementById('bankrollDisplay').innerHTML = state.startBankroll ? 
        `üíº Balance: ${state.currentBankroll.toFixed(2)} | Profit: ${(state.currentBankroll - state.startBankroll).toFixed(2)}<br>` +
        `Bet: $${(state.betState.currentBetUnits * state.baseUnit).toFixed(2)} (${state.betState.currentBetUnits} units)<br>` +
        `Losses: ${previousLosses}<br>` +
        `<span class="${state.betState.cycleProfit >= 1 ? 'cycle-reset' : ''}">Cycle: $${(state.betState.cycleProfit * state.baseUnit).toFixed(2)}</span><br>` +
        `Total: $${(state.betState.totalProfit * state.baseUnit).toFixed(2)}<br>` +
        `Stop: ${stopProfitDisplay} | ${state.stopProfitReached ? 'üö® Reached' : 'Active'}` : 
        'üíº Balance: - | Profit: -';
      document.getElementById('bankrollInput').value = state.startBankroll || '';
      document.getElementById('basebetInput').value = state.baseUnit || '';
      document.getElementById('stopProfitType').value = state.stopProfitType;
      document.getElementById('stopProfitInput').value = state.stopProfitValue || '';
    }

    function saveMemoryFast() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(saveMemory, 300);
    }

    async function saveMemory() {
      try {
        localStorage.setItem('baccaratStats', JSON.stringify(state));
      } catch (e) {
        alert('Error saving to cloud');
      }
    }

    async function loadMemory() {
      try {
        const saved = JSON.parse(localStorage.getItem('baccaratStats') || '{}');
        state.wins = Number(saved.wins) || 0;
        state.losses = Number(saved.losses) || 0;
        state.baseUnit = Number(saved.baseUnit) || 0;
        state.startBankroll = Number(saved.startBankroll) || 0;
        state.currentBankroll = Number(saved.currentBankroll) || 0;
        state.stopProfitType = saved.stopProfitType || 'percentage';
        state.stopProfitValue = Number(saved.stopProfitValue) || 0;
        state.stopProfitEffective = Number(saved.stopProfitEffective) || 0;
        state.stopProfitReached = saved.stopProfitReached || false;
        state.betState = saved.betState || { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
        state.history = Array.isArray(saved.history) ? saved.history : [];
        state.outcomes = Array.isArray(saved.outcomes) ? saved.outcomes : [];
        updateDisplay();
      } catch (e) {
        alert('Error loading from cloud');
      }
    }

    function toggleAdvanced() {
      const section = document.getElementById('advancedControls');
      const button = document.querySelector('.toggle-section');
      section.classList.toggle('show');
      button.innerText = section.classList.contains('show') ? 'Hide Advanced' : 'Show Advanced';
    }

    // Initialize
    window.onload = loadMemory;
    updateDisplay();
  </script>
</body>
</html>
