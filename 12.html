<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BFC VIP</title>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      padding: 20px;
      margin: 0;
      background-color: #f4f6f8;
      color: #222;
    }
    h1, h2, h3 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 28px;
      color: #333;
    }
    h2 { font-size: 24px; }
    h3 { font-size: 20px; }
    .container {
      max-width: 800px;
      margin: auto;
      background: white;
      padding: 1rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: #fff;
      transition: background 0.3s;
    }
    button:hover { filter: brightness(85%); }
    .player { background-color: #2196F3; }
    .banker { background-color: #E91E63; }
    .tie { background-color: #FFC107; }
    .clear-all { background-color: #dc3545; }
    .set-bet, .reset-bet, .mm-action, .admin-action, .save-apply {
      background-color: #6c757d;
    }
    .fix-subscription { background-color: #28a745; }
    .record-win { background-color: #28a745; }
    .record-loss { background-color: #dc3545; }
    .reset-cycle { background-color: #17a2b8; }
    .new-session { background-color: #ff9800; }
    .toggle-section {
      background-color: #6c757d;
      padding: 8px;
      width: 100%;
      text-align: center;
    }
    .collapsible { display: none; }
    .collapsible.show { display: block; }
    .prediction {
      font-weight: bold;
      font-size: 1.2rem;
      text-align: center;
      margin-top: 1rem;
    }
    .shoe-type, .card-count {
      text-align: center;
      font-size: 1rem;
      margin-top: 0.5rem;
      color: #555;
    }
    .history {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .history div {
      width: 40px;
      height: 30px;
      margin: 3px;
      line-height: 30px;
      text-align: center;
      color: white;
      font-weight: bold;
      border-radius: 5px;
      position: relative;
    }
    .P { background-color: #2196F3; }
    .B { background-color: #E91E63; }
    .T { background-color: #FFC107; }
    .W::after, .L::after {
      content: attr(data-outcome);
      position: absolute;
      top: -10px;
      right: -5px;
      font-size: 12px;
      color: #fff;
      background: #28a745;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
    }
    .L::after { background: #dc3545; }
    .stats {
      padding: 15px;
      text-align: center;
    }
    .section {
      text-align: center;
      margin: 12px 0;
      font-size: 18px;
      font-weight: 700;
    }
    .bet-controls, .mm-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      margin-bottom: 1rem;
      width: 100%;
      max-width: 90vw;
    }
    input[type=number], select, input[type=datetime-local], input[type=email], input[type=password], input[type=checkbox] {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      width: 120px;
    }
    label {
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .cycle-reset {
      color: #28a745;
      font-weight: 700;
    }
    .error {
      color: #dc3545;
      text-align: center;
    }
    .hidden { display: none; }
    .admin-panel table, .mm-history table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    .admin-panel th, .admin-panel td, .mm-history th, .mm-history td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }
    .admin-panel th, .mm-history th {
      background-color: #f0f0f0;
    }
    .admin-panel button { background-color: #dc3545; }
    .online-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .online { background-color: #28a745; }
    .offline { background-color: #dc3545; }
    .algorithm-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }
    .mm-section {
      margin-top: 20px;
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    textarea {
      width: 100%;
      max-width: 300px;
      height: 60px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 8px;
      resize: vertical;
    }
    @media (max-width: 500px) {
      .flex-row, .bet-controls, .mm-controls, .algorithm-checkboxes {
        flex-direction: column;
        align-items: stretch;
      }
      input[type=number], input[type=datetime-local], select, input[type=email], input[type=password], textarea {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container hidden" id="appContainer">
    <h1>BFC VIP</h1>
    <div class="section" id="subscriptionStatus">Subscription: -</div>
    <div class="error" id="errorMessage"></div>
    <div class="flex-row">
      <button onclick="signOutUser()" aria-label="Sign out">Sign Out</button>
    </div>
    <div class="flex-row">
      <button class="player" onclick="recordResult('P')" aria-label="Record Player result">Player</button>
      <button class="banker" onclick="recordResult('B')" aria-label="Record Banker result">Banker</button>
      <button class="tie" onclick="recordResult('T')" aria-label="Record Tie result">Tie</button>
      <button class="clear-all" onclick="clearAll()" aria-label="Clear all data">Clear All</button>
      <button class="undo" onclick="undo()" aria-label="Undo last action">Undo</button>
    </div>

    <div class="prediction" id="prediction">Waiting for input...</div>
    <div class="shoe-type admin-only" id="shoeType">Detected Pattern: N/A</div>
    <div class="card-count admin-only" id="cardCountDisplay">Card Count: N/A</div>
    <div class="section">Showing last 10 results</div>
    <div class="history" id="historyDisplay"></div>

    <div class="stats">
      <div class="section" id="currentWager">üíµ Current Bet: 0</div>
      <div class="section" id="bankrollDisplay">üíº Balance: - | Profit: -</div>
      <div class="section" id="streakInfo"></div>
      <div class="section">
        ‚úÖ <span id="wins">0</span> | ‚ùå <span id="losses">0</span> | üìä <span id="accuracy">0%</span>
      </div>
      <div class="mm-section">
        <h3>üéØ Baccarat Money Management Tracker</h3>
        <div class="mm-controls">
          <label><span>Initial Bankroll</span><input type="number" id="bankrollInput" placeholder="Bankroll" min="0.01" step="0.01" aria-label="Set bankroll"></label>
          <label><span>Base Bet</span><input type="number" id="baseBetInput" placeholder="Base Bet ($)" min="0.01" step="0.01" aria-label="Set base bet"></label>
          <label><span>Target Profit / Cycle</span><input type="number" id="targetProfitInput" placeholder="Target Profit" min="0" step="0.01" aria-label="Set target profit"></label>
          <label><span>Increment / Cycle</span><input type="number" id="incrementInput" placeholder="Increment" min="0" step="0.01" aria-label="Set increment per cycle"></label>
          <label><span>Commission (Banker)</span><input type="number" id="commissionInput" placeholder="Commission %" min="0" max="100" step="0.01" aria-label="Set banker commission"></label>
          <label><span>Stop Loss</span><input type="number" id="stopLossInput" placeholder="Stop Loss" min="0" step="0.01" aria-label="Set stop loss"></label>
          <label><span>Attack Mode</span><input type="checkbox" id="attackModeInput" aria-label="Enable attack mode"></label>
          <button class="save-apply" onclick="saveApplyMM()" aria-label="Save and apply money management settings">üíæ Save / Apply</button>
        </div>
        <div class="section" id="currentBankrollDisplay">Current Bankroll: 0</div>
        <div class="section" id="cycleProfitDisplay">Cycle Profit / Target: 0 / 0 | Cycle #1</div>
        <div class="section" id="modeDisplay">Mode: Base | Step 1</div>
        <div class="section" id="suggestedBetDisplay">Suggested Next Bet: 0 (Base Mode)</div>
        <div class="flex-row">
          <button class="record-win" onclick="recordWin()" aria-label="Record win">‚úÖ Record Win</button>
          <button class="record-loss" onclick="recordLoss()" aria-label="Record loss">‚ùå Record Loss</button>
          <button class="reset-cycle" onclick="forceResetCycle()" aria-label="Force reset cycle">üîÅ Force Reset Cycle</button>
          <button class="new-session" onclick="newSession()" aria-label="New session">üßπ New Session</button>
        </div>
        <div class="mm-section">
          <h3>Table Notes</h3>
          <textarea id="tableNotes" placeholder="Enter notes..." aria-label="Table notes"></textarea>
        </div>
        <div class="mm-section">
          <h3>History</h3>
          <div class="section">Commission auto-applied on Banker wins.</div>
          <table class="mm-history" id="mmHistoryTable">
            <thead>
              <tr>
                <th>#</th>
                <th>Mode</th>
                <th>Step</th>
                <th>Side</th>
                <th>Bet</th>
                <th>Result</th>
                <th>P/L</th>
                <th>Cycle Profit</th>
                <th>Bankroll</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody id="mmHistoryTableBody"></tbody>
          </table>
        </div>
      </div>
      <button class="toggle-section" onclick="toggleAdvanced()" aria-label="Toggle advanced controls">Show Advanced</button>
      <div class="flex-row collapsible" id="advancedControls">
        <button class="reset-bet" onclick="resetBet()" aria-label="Reset bet">Reset Bet</button>
        <button class="mm-action" onclick="saveMemory()" aria-label="Save state">üíæ</button>
        <button class="mm-action" onclick="loadMemory()" aria-label="Load state">üì•</button>
        <button class="mm-action" onclick="resetStats()" aria-label="Reset stats">üîÑ Reset Stats</button>
        <button class="mm-action" onclick="resetMemory()" aria-label="Reset memory">üß† Reset Memory</button>
      </div>
    </div>

    <div class="admin-panel hidden" id="adminPanel">
      <h2>Admin Panel</h2>
      <div class="section">
        <h3>Create User</h3>
        <div class="flex-row">
          <label><span>Email</span><input type="email" id="newUserEmail" placeholder="Email" aria-label="New user email"></label>
          <label><span>Password</span><input type="password" id="newUserPassword" placeholder="Password" aria-label="New user password"></label>
          <label><span>Admin</span><input type="checkbox" id="newUserIsAdmin" aria-label="New user admin status"></label>
          <button class="admin-action" onclick="createUser()">Create User</button>
        </div>
      </div>
      <div class="section">
        <h3>Manage Users</h3>
        <table id="userTable">
          <thead>
            <tr>
              <th>Email</th>
              <th>Subscription End (PST)</th>
              <th>Admin</th>
              <th>Add Time</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="userTableBody"></tbody>
        </table>
      </div>
      <div class="section">
        <h3>Add Subscription Time</h3>
        <div class="flex-row">
          <label><span>User Email</span><input type="email" id="extendUserEmail" placeholder="User Email" aria-label="User email to extend subscription"></label>
          <label>
            <select id="extendTimeUnit" aria-label="Select time unit">
              <option value="hours">Hours</option>
              <option value="days">Days</option>
              <option value="test">24-Hour Test</option>
            </select>
          </label>
          <label><span>Amount</span><input type="number" id="extendTimeAmount" placeholder="Amount" min="1" step="1" aria-label="Amount of time to add"></label>
          <button class="admin-action" onclick="extendSubscription()">Add Time</button>
        </div>
      </div>
      <div class="section">
        <h3>Algorithm Selection</h3>
        <div class="flex-row algorithm-checkboxes">
          <label><input type="checkbox" id="bayesianCheckbox" onchange="setAlgorithms()" aria-label="Use Bayesian algorithm">Bay Dm#Bayesian</label>
          <label><input type="checkbox" id="chatgptCheckbox" onchange="setAlgorithms()" aria-label="Use ChatGPT algorithm">ChatGPT</label>
          <label><input type="checkbox" id="grokCheckbox" onchange="setAlgorithms()" aria-label="Use Grok algorithm">Grok</label>
          <label><input type="checkbox" id="neuralnetCheckbox" onchange="setAlgorithms()" aria-label="Use Neural Network algorithm">Neural Network</label>
        </div>
      </div>
      <div class="section">
        <h3>Online Users</h3>
        <table id="onlineUsersTable">
          <thead>
            <tr>
              <th>Email</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody id="onlineUsersTableBody"></tbody>
        </table>
      </div>
      <div class="section">
        <h3>Non-Admin Algorithm Accuracy</h3>
        <table id="algorithmAccuracyTable">
          <thead>
            <tr>
              <th>Email</th>
              <th>Bayesian</th>
              <th>ChatGPT</th>
              <th>Grok</th>
              <th>Neural Net</th>
            </tr>
          </thead>
          <tbody id="algorithmAccuracyTableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, signOut, onAuthStateChanged, createUserWithEmailAndPassword } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getAnalytics, logEvent } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-analytics.js';
    import { getFirestore, doc, getDoc, setDoc, collection, getDocs, query, where, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js';

    const { DateTime } = luxon;

    const firebaseConfig = {
      apiKey: "AIzaSyBs3LHGZA_8spAwQ5kgULiqcZmKqcIvZiI",
      authDomain: "bfc-vip.firebaseapp.com",
      projectId: "bfc-vip",
      storageBucket: "bfc-vip.appspot.com",
      messagingSenderId: "92211995630",
      appId: "1:92211995630:web:186a26085329fc607724ff",
      measurementId: "G-1EBPP36F59"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const analytics = getAnalytics(app);

    let globalSelectedAlgorithms = ['bayesian'];
    let isAdmin = false;
    let onlineUsersUnsubscribe = null;
    let accuracyUnsubscribe = null;
    let globalSettingsUnsubscribe = null;

    function showMessage(message) {
      const errorMessage = document.getElementById('errorMessage');
      errorMessage.innerText = message;
      setTimeout(() => { errorMessage.innerText = ''; }, 5000);
    }

    function signOutUser() {
      const user = auth.currentUser;
      if (user) {
        setDoc(doc(db, 'users', user.uid), { isOnline: false }, { merge: true });
      }
      signOut(auth).then(() => {
        window.location.href = 'login.html';
      });
    }

    async function createUser() {
      const email = document.getElementById('newUserEmail').value;
      const password = document.getElementById('newUserPassword').value;
      const isAdmin = document.getElementById('newUserIsAdmin').checked;
      if (!email || !password) {
        showMessage('Please fill in email and password');
        return;
      }
      try {
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const subscriptionEnd = DateTime.now().setZone('Asia/Manila').plus({ days: 60 }).toMillis();
        await setDoc(doc(db, 'users', userCredential.user.uid), {
          email: userCredential.user.email,
          subscriptionEnd,
          isAdmin,
          isOnline: false,
          state: {
            history: [],
            outcomes: [],
            wins: 0,
            losses: 0,
            mmState: {
              initialBankroll: 0,
              currentBankroll: 0,
              baseBet: 0,
              targetProfit: 0,
              incrementPerCycle: 0,
              commission: 5,
              stopLoss: 0,
              attackMode: false,
              currentBet: 0,
              cycleProfit: 0,
              cycleNumber: 1,
              mode: 'Base',
              step: 1,
              betHistory: [],
              tableNotes: ''
            },
            patternMemory: {},
            predictionPerformance: { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } },
            cardCounts: { low: 0, high: 0, totalCards: 0, decks: 8 },
            accuracyWindow: [],
            selectedAlgorithms: []
          }
        });
        showMessage('User created successfully');
        logEvent(analytics, 'create_user', { email, isAdmin });
        document.getElementById('newUserEmail').value = '';
        document.getElementById('newUserPassword').value = '';
        document.getElementById('newUserIsAdmin').checked = false;
        loadUsers();
      } catch (error) {
        showMessage('Error creating user: ' + error.message);
        logEvent(analytics, 'create_user', { email, success: false, error: error.code });
      }
    }

    async function updateUserSubscription(uid) {
      const subscriptionEndInput = document.getElementById(`subscriptionEnd_${uid}`).value;
      if (!subscriptionEndInput) {
        showMessage('Please select a valid subscription date');
        return;
      }
      const subscriptionEnd = DateTime.fromISO(subscriptionEndInput, { zone: 'Asia/Manila' }).toMillis();
      if (isNaN(subscriptionEnd)) {
        showMessage('Invalid subscription date');
        return;
      }
      try {
        await setDoc(doc(db, 'users', uid), { subscriptionEnd }, { merge: true });
        showMessage('Subscription updated');
        logEvent(analytics, 'update_subscription', { uid });
        loadUsers();
      } catch (error) {
        showMessage('Error updating subscription: ' + error.message);
      }
    }

    async function fixUserSubscription(uid) {
      try {
        const subscriptionEnd = DateTime.now().setZone('Asia/Manila').plus({ days: 60 }).toMillis();
        await setDoc(doc(db, 'users', uid), { subscriptionEnd }, { merge: true });
        showMessage('Subscription fixed to 60 days from now');
        logEvent(analytics, 'fix_subscription', { uid });
        loadUsers();
      } catch (error) {
        showMessage('Error fixing subscription: ' + error.message);
      }
    }

    async function extendSubscription() {
      const email = document.getElementById('extendUserEmail').value;
      const timeUnit = document.getElementById('extendTimeUnit').value;
      const timeAmount = parseInt(document.getElementById('extendTimeAmount').value);
      if (!email) {
        showMessage('Please enter a user email');
        return;
      }
      if (timeUnit !== 'test' && (!timeAmount || timeAmount < 1)) {
        showMessage('Please enter a valid time amount');
        return;
      }
      try {
        const userQuery = query(collection(db, 'users'), where('email', '==', email));
        const querySnapshot = await getDocs(userQuery);
        if (querySnapshot.empty) {
          showMessage('User not found');
          return;
        }
        const userDoc = querySnapshot.docs[0];
        const uid = userDoc.id;
        const currentSubscriptionEnd = Number.isInteger(userDoc.data().subscriptionEnd) ? userDoc.data().subscriptionEnd : DateTime.now().setZone('Asia/Manila').toMillis();
        const currentTime = DateTime.now().setZone('Asia/Manila').toMillis();
        const effectiveStart = Math.max(currentSubscriptionEnd, currentTime);
        let additionalTime = timeUnit === 'test' ? 24 * 60 * 60 * 1000 :
                            timeUnit === 'hours' ? timeAmount * 60 * 60 * 1000 :
                            timeAmount * 24 * 60 * 60 * 1000;
        const newSubscriptionEnd = effectiveStart + additionalTime;
        await setDoc(doc(db, 'users', uid), { subscriptionEnd: newSubscriptionEnd }, { merge: true });
        showMessage(`Subscription extended to ${DateTime.fromMillis(newSubscriptionEnd, { zone: 'Asia/Manila' }).toLocaleString(DateTime.DATETIME_FULL)}`);
        logEvent(analytics, 'extend_subscription', { email, timeUnit, timeAmount });
        document.getElementById('extendUserEmail').value = '';
        document.getElementById('extendTimeUnit').value = 'hours';
        document.getElementById('extendTimeAmount').value = '';
        loadUsers();
      } catch (error) {
        showMessage('Error extending subscription: ' + error.message);
        logEvent(analytics, 'extend_subscription', { email, success: false, error: error.code });
      }
    }

    async function deleteUser(uid) {
      if (!confirm('Are you sure you want to delete this user?')) return;
      try {
        await setDoc(doc(db, 'users', uid), { deleted: true, isOnline: false }, { merge: true });
        showMessage('User marked as deleted (use Admin SDK for full deletion)');
        logEvent(analytics, 'delete_user', { uid });
        loadUsers();
      } catch (error) {
        showMessage('Error deleting user: ' + error.message);
      }
    }

    async function loadUsers() {
      const userTableBody = document.getElementById('userTableBody');
      userTableBody.innerHTML = '';
      try {
        const querySnapshot = await getDocs(collection(db, 'users'));
        querySnapshot.forEach(doc => {
          const user = doc.data();
          if (user.deleted) return;
          const row = document.createElement('tr');
          const subscriptionEnd = Number.isInteger(user.subscriptionEnd) ? user.subscriptionEnd : null;
          const dateValue = subscriptionEnd ? DateTime.fromMillis(subscriptionEnd, { zone: 'Asia/Manila' }).toFormat('yyyy-MM-dd\'T\'HH:mm') : '';
          row.innerHTML = `
            <td>${user.email}</td>
            <td>${subscriptionEnd ? `<input type="datetime-local" id="subscriptionEnd_${doc.id}" value="${dateValue}" aria-label="Subscription end date for ${user.email}">` : 'Not Set'}</td>
            <td>${user.isAdmin ? 'Yes' : 'No'}</td>
            <td><button class="admin-action" onclick="extendSubscriptionFor('${doc.id}', '${user.email}')">Add Time</button></td>
            <td>
              ${subscriptionEnd ? `<button class="admin-action" onclick="updateUserSubscription('${doc.id}')">Update</button>` : `<button class="fix-subscription" onclick="fixUserSubscription('${doc.id}')">Fix</button>`}
              <button class="admin-action" onclick="deleteUser('${doc.id}')">Delete</button>
            </td>
          `;
          userTableBody.appendChild(row);
        });
      } catch (error) {
        showMessage('Error loading users: ' + error.message);
      }
    }

    function loadOnlineUsers() {
      if (!isAdmin) return;
      const onlineUsersTableBody = document.getElementById('onlineUsersTableBody');
      onlineUsersTableBody.innerHTML = '';
      try {
        const unsubscribe = onSnapshot(collection(db, 'users'), (querySnapshot) => {
          onlineUsersTableBody.innerHTML = '';
          querySnapshot.forEach(doc => {
            const user = doc.data();
            if (user.deleted) return;
            const row = document.createElement('tr');
            const status = user.isOnline ? 'Online' : 'Offline';
            const statusClass = user.isOnline ? 'online' : 'offline';
            row.innerHTML = `
              <td>${user.email}</td>
              <td><span class="online-indicator ${statusClass}"></span>${status}</td>
            `;
            onlineUsersTableBody.appendChild(row);
          });
        });
        return unsubscribe;
      } catch (error) {
        showMessage('Error loading online users: ' + error.message);
      }
    }

    function loadAlgorithmAccuracy() {
      if (!isAdmin) return;
      const accuracyTableBody = document.getElementById('algorithmAccuracyTableBody');
      accuracyTableBody.innerHTML = '';
      try {
        const unsubscribe = onSnapshot(collection(db, 'users'), (querySnapshot) => {
          accuracyTableBody.innerHTML = '';
          querySnapshot.forEach(doc => {
            const user = doc.data();
            if (user.deleted || user.isAdmin) return;
            const state = user.state || {};
            const predictionPerformance = state.predictionPerformance || { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
            let bayesianCorrect = 0, bayesianTotal = 0;
            for (let n = 2; n <= 5; n++) {
              bayesianCorrect += predictionPerformance[n]?.correct || 0;
              bayesianTotal += predictionPerformance[n]?.total || 0;
            }
            const bayesianAccuracy = bayesianTotal > 0 ? (bayesianCorrect / bayesianTotal * 100).toFixed(1) + '%' : 'N/A';
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${user.email}</td>
              <td>${bayesianAccuracy}</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
            `;
            accuracyTableBody.appendChild(row);
          });
        });
        return unsubscribe;
      } catch (error) {
        showMessage('Error loading algorithm accuracy: ' + error.message);
      }
    }

    function loadGlobalSettings() {
      try {
        const unsubscribe = onSnapshot(doc(db, 'settings', 'global'), (docSnapshot) => {
          if (docSnapshot.exists()) {
            globalSelectedAlgorithms = docSnapshot.data().selectedAlgorithms || ['bayesian'];
          } else {
            globalSelectedAlgorithms = ['bayesian'];
            setDoc(doc(db, 'settings', 'global'), { selectedAlgorithms: globalSelectedAlgorithms }, { merge: true });
          }
          if (!isAdmin) {
            updatePrediction();
          }
        });
        return unsubscribe;
      } catch (error) {
        showMessage('Error loading global settings: ' + error.message);
        globalSelectedAlgorithms = ['bayesian'];
      }
    }

    onAuthStateChanged(auth, async user => {
      const errorMessage = document.getElementById('errorMessage');
      errorMessage.innerText = '';
      if (user) {
        try {
          const userDoc = await getDoc(doc(db, 'users', user.uid));
          if (userDoc.exists()) {
            const userData = userDoc.data();
            isAdmin = userData.isAdmin || false;
            const subscriptionEnd = Number.isInteger(userData.subscriptionEnd) ? userData.subscriptionEnd : null;
            const currentTime = DateTime.now().setZone('Asia/Manila').toMillis();
            if (subscriptionEnd && currentTime < subscriptionEnd) {
              await setDoc(doc(db, 'users', user.uid), { isOnline: true }, { merge: true });
              document.getElementById('appContainer').classList.remove('hidden');
              document.getElementById('subscriptionStatus').innerText = `Subscription: Active until ${DateTime.fromMillis(subscriptionEnd, { zone: 'Asia/Manila' }).toLocaleString(DateTime.DATETIME_FULL)}`;
              document.getElementById('adminPanel').classList.toggle('hidden', !isAdmin);
              document.querySelectorAll('.admin-only').forEach(el => el.classList.toggle('hidden', !isAdmin));
              if (isAdmin) {
                loadUsers();
                onlineUsersUnsubscribe = loadOnlineUsers();
                accuracyUnsubscribe = loadAlgorithmAccuracy();
                const selectedAlgorithms = userData.state?.selectedAlgorithms || globalSelectedAlgorithms;
                document.getElementById('bayesianCheckbox').checked = selectedAlgorithms.includes('bayesian');
                document.getElementById('chatgptCheckbox').checked = selectedAlgorithms.includes('chatgpt');
                document.getElementById('grokCheckbox').checked = selectedAlgorithms.includes('grok');
                document.getElementById('neuralnetCheckbox').checked = selectedAlgorithms.includes('neuralnet');
              }
              globalSettingsUnsubscribe = loadGlobalSettings();
              loadMemory();
            } else {
              await setDoc(doc(db, 'users', user.uid), { isOnline: false }, { merge: true });
              showMessage('Your subscription has expired or is invalid. Contact admin to renew.');
              signOut(auth);
            }
          } else {
            showMessage('User data not found. Contact admin.');
            signOut(auth);
          }
        } catch (error) {
          showMessage('Error checking subscription: ' + error.message);
          await setDoc(doc(db, 'users', user.uid), { isOnline: false }, { merge: true });
          signOut(auth);
        }
      } else {
        if (onlineUsersUnsubscribe) onlineUsersUnsubscribe();
        if (accuracyUnsubscribe) accuracyUnsubscribe();
        if (globalSettingsUnsubscribe) globalSettingsUnsubscribe();
        window.location.href = 'login.html';
      }
    });

    window.addEventListener('beforeunload', () => {
      const user = auth.currentUser;
      if (user) {
        setDoc(doc(db, 'users', user.uid), { isOnline: false }, { merge: true });
      }
    });

    let state = {
      history: [],
      outcomes: [],
      wins: 0,
      losses: 0,
      mmState: {
        initialBankroll: 0,
        currentBankroll: 0,
        baseBet: 0,
        targetProfit: 0,
        incrementPerCycle: 0,
        commission: 5,
        stopLoss: 0,
        attackMode: false,
        currentBet: 0,
        cycleProfit: 0,
        cycleNumber: 1,
        mode: 'Base',
        step: 1,
        betHistory: [],
        tableNotes: ''
      },
      patternMemory: {},
      predictionPerformance: { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } },
      cardCounts: { low: 0, high: 0, totalCards: 0, decks: 8 },
      accuracyWindow: [],
      selectedAlgorithms: []
    };
    let snapshots = [];
    let saveTimeout = null;
    let pendingBet = null;

    function learnPattern(latest) {
      for (let n = 2; n <= 5; n++) {
        if (state.history.length >= n) {
          const seq = state.history.slice(-n).join('');
          const key = seq.slice(0, -1);
          const next = seq.slice(-1);
          if (next !== 'T') {
            if (!state.patternMemory[key]) state.patternMemory[key] = { P: 0, B: 0 };
            const recencyWeight = 1 + 0.1 * (state.history.length - state.history.lastIndexOf(seq));
            state.patternMemory[key][next] += recencyWeight;
          }
        }
      }
    }

    function unlearnPattern(latest) {
      for (let n = 2; n <= 5; n++) {
        if (state.history.length >= n) {
          const seq = state.history.slice(-n).join('');
          const key = seq.slice(0, -1);
          const next = seq.slice(-1);
          if (next !== 'T' && state.patternMemory[key]) {
            const recencyWeight = 1 + 0.1 * (state.history.length - state.history.lastIndexOf(seq));
            state.patternMemory[key][next] = Math.max(0, state.patternMemory[key][next] - recencyWeight);
          }
        }
      }
    }

    function getDynamicConfidenceThreshold() {
      const winRate = state.wins + state.losses > 0 ? state.wins / (state.wins + state.losses) : 0.5;
      const bankrollRatio = state.mmState.currentBankroll / state.mmState.initialBankroll || 1;
      const baseThreshold = 60;
      const streakPenalty = state.outcomes.slice(-3).every(v => v === 'L') ? 10 : 0;
      const bankrollPenalty = bankrollRatio < 0.5 ? 10 : 0;
      return baseThreshold + streakPenalty + bankrollPenalty;
    }

    function getShoeType() {
      let streaks = 0;
      for (let i = 1; i < state.history.length; i++) {
        if (state.history[i] === state.history[i - 1]) streaks++;
      }
      const chopScore = state.history.length > 1 ? state.history.length - 1 - streaks : 0;
      const chopRatio = state.history.length > 1 ? chopScore / (state.history.length - 1) : 0;
      if (chopRatio > 0.7) return 'Chop';
      if (chopRatio < 0.3) return 'Streak';
      return 'Balanced';
    }

    function calculateTrueCount() {
      const runningCount = state.cardCounts.high - state.cardCounts.low;
      const remainingDecks = Math.max(0.1, (state.cardCounts.decks * 52 - state.cardCounts.totalCards) / 52);
      return runningCount / remainingDecks;
    }

    function estimateCardsDrawn(result) {
      let low = 0, high = 0, total = 4;
      if (result === 'P') {
        low += 1;
        high += 0.5;
        if (Math.random() < 0.4) total = 6;
      } else if (result === 'B') {
        high += 1;
        low += 0.5;
        if (Math.random() < 0.4) total = 6;
      } else if (result === 'T') {
        high += 1;
        total = Math.random() < 0.3 ? 6 : 4;
      }
      return { low, high, total };
    }

    function calculateRecentAccuracy() {
      if (state.accuracyWindow.length === 0) return 1.0;
      const wins = state.accuracyWindow.filter(o => o === 'W').length;
      return wins / state.accuracyWindow.length;
    }

    function updateCardCountDisplay() {
      if (!isAdmin) return;
      const trueCount = calculateTrueCount();
      const remainingDecks = (state.cardCounts.decks * 52 - state.cardCounts.totalCards) / 52;
      const recentAccuracy = (calculateRecentAccuracy() * 100).toFixed(1);
      document.getElementById('cardCountDisplay').innerText = 
        `Card Count: Low=${state.cardCounts.low.toFixed(1)}, High=${state.cardCounts.high.toFixed(1)}, True Count=${trueCount.toFixed(2)}, Decks Remaining=${remainingDecks.toFixed(1)}, Recent Accuracy=${recentAccuracy}%`;
    }

    function bayesianPrediction() {
      let bestPrediction = { predict: 'P', confidence: 50, score: 0, algo: 'bayesian' };
      const threshold = getDynamicConfidenceThreshold();
      const priorP = 0.4462;
      const priorB = 0.4586;
      const priorT = 0.0952;
      const shoeType = getShoeType();
      const trueCount = calculateTrueCount();
      
      let adjustedPriorP = priorP;
      let adjustedPriorB = priorB;
      if (trueCount > 1) {
        adjustedPriorB += 0.02 * trueCount;
        adjustedPriorP -= 0.01 * trueCount;
      } else if (trueCount < -1) {
        adjustedPriorP += 0.02 * Math.abs(trueCount);
        adjustedPriorB -= 0.01 * Math.abs(trueCount);
      }
      const totalPrior = adjustedPriorP + adjustedPriorB + priorT;
      adjustedPriorP /= totalPrior;
      adjustedPriorB /= totalPrior;
      
      for (let n = 5; n >= 2; n--) {
        if (state.history.length >= n) {
          const key = state.history.slice(-n + 1).join('');
          if (state.patternMemory[key]) {
            let p = state.patternMemory[key].P || 0;
            let b = state.patternMemory[key].B || 0;
            const total = p + b;
            if (total > 0) {
              if (shoeType === 'Streak' && state.history[state.history.length - 1] === 'P') {
                p *= 1.2;
              } else if (shoeType === 'Streak' && state.history[state.history.length - 1] === 'B') {
                b *= 1.2;
              } else if (shoeType === 'Chop') {
                p *= state.history[state.history.length - 1] === 'B' ? 1.2 : 0.8;
                b *= state.history[state.history.length - 1] === 'P' ? 1.2 : 0.8;
              }
              const alpha = 2;
              const posteriorP = (p + alpha * adjustedPriorP) / (total + alpha);
              const posteriorB = (b + alpha * adjustedPriorB) / (total + alpha);
              const frequencyWeight = total / (state.wins + state.losses + 1);
              const lengthWeight = n / 5;
              const recencyWeight = 1 / (state.history.length - state.history.lastIndexOf(key) + 1);
              const perfWeight = state.predictionPerformance[n].total > 0 ? 
                state.predictionPerformance[n].correct / state.predictionPerformance[n].total : 1;
              const score = frequencyWeight * lengthWeight * recencyWeight * perfWeight;
              const confidence = Math.round(100 * Math.max(posteriorP, posteriorB));
              const predict = posteriorP > posteriorB ? 'P' : 'B';
              if (score > bestPrediction.score && confidence > threshold) {
                bestPrediction = { predict, confidence, score, algo: 'bayesian' };
              }
            }
          }
        }
      }
      return bestPrediction;
    }

    function selectPredictionAlgorithm() {
      const algorithms = isAdmin ? (state.selectedAlgorithms.length > 0 ? state.selectedAlgorithms : ['bayesian']) : globalSelectedAlgorithms;
      const predictions = [];
      if (algorithms.includes('bayesian')) predictions.push(bayesianPrediction());
      return predictions.reduce((best, current) => 
        current.confidence > best.confidence ? current : best, 
        { predict: 'P', confidence: 0, score: 0, algo: 'bayesian' }
      );
    }

    async function setAlgorithms() {
      if (!isAdmin) return;
      const selectedAlgorithms = [];
      if (document.getElementById('bayesianCheckbox').checked) selectedAlgorithms.push('bayesian');
      if (document.getElementById('chatgptCheckbox').checked) selectedAlgorithms.push('chatgpt');
      if (document.getElementById('grokCheckbox').checked) selectedAlgorithms.push('grok');
      if (document.getElementById('neuralnetCheckbox').checked) selectedAlgorithms.push('neuralnet');
      state.selectedAlgorithms = selectedAlgorithms;
      try {
        await setDoc(doc(db, 'settings', 'global'), { selectedAlgorithms: selectedAlgorithms.length > 0 ? selectedAlgorithms : ['bayesian'] }, { merge: true });
        saveMemoryFast();
        updatePrediction();
        showMessage(`Selected algorithms: ${selectedAlgorithms.length > 0 ? selectedAlgorithms.join(', ') : 'Bayesian (default)'}`);
        logEvent(analytics, 'set_algorithms', { algorithms: selectedAlgorithms });
      } catch (error) {
        showMessage('Error saving algorithm selection: ' + error.message);
      }
    }

    function saveApplyMM() {
      const initialBankroll = parseFloat(document.getElementById('bankrollInput').value);
      const baseBet = parseFloat(document.getElementById('baseBetInput').value);
      const targetProfit = parseFloat(document.getElementById('targetProfitInput').value) || 0;
      const incrementPerCycle = parseFloat(document.getElementById('incrementInput').value) || 0;
      const commission = parseFloat(document.getElementById('commissionInput').value) || 5;
      const stopLoss = parseFloat(document.getElementById('stopLossInput').value) || 0;
      const attackMode = document.getElementById('attackModeInput').checked;
      const tableNotes = document.getElementById('tableNotes').value;
      if (isNaN(initialBankroll) || initialBankroll <= 0 || isNaN(baseBet) || baseBet <= 0) {
        showMessage('Invalid bankroll or base bet');
        return;
      }
      if (targetProfit < 0 || incrementPerCycle < 0 || commission < 0 || commission > 100 || stopLoss < 0) {
        showMessage('Invalid money management parameters');
        return;
      }
      snapshots.push(JSON.parse(JSON.stringify(state)));
      state.mmState = {
        initialBankroll,
        currentBankroll: initialBankroll,
        baseBet,
        targetProfit,
        incrementPerCycle,
        commission,
        stopLoss,
        attackMode,
        currentBet: baseBet,
        cycleProfit: 0,
        cycleNumber: 1,
        mode: 'Base',
        step: 1,
        betHistory: [],
        tableNotes
      };
      state.wins = 0;
      state.losses = 0;
      state.outcomes = [];
      state.history = [];
      state.patternMemory = {};
      state.predictionPerformance = { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
      state.cardCounts = { low: 0, high: 0, totalCards: 0, decks: 8 };
      state.accuracyWindow = [];
      saveMemoryFast();
      updateDisplay();
    }

    function calculateNextBet() {
      const { baseBet, cycleProfit, targetProfit, incrementPerCycle, attackMode, step } = state.mmState;
      let nextBet = baseBet;
      if (attackMode && cycleProfit < 0) {
        nextBet = baseBet * Math.pow(2, step - 1);
      } else if (cycleProfit >= targetProfit) {
        state.mmState.cycleNumber++;
        state.mmState.cycleProfit = 0;
        state.mmState.mode = 'Base';
        state.mmState.step = 1;
        state.mmState.baseBet += incrementPerCycle;
        nextBet = state.mmState.baseBet;
      } else if (cycleProfit < 0) {
        state.mmState.mode = 'Recovery';
        state.mmState.step++;
        nextBet = baseBet * Math.pow(2, step - 1);
      }
      state.mmState.currentBet = Math.min(nextBet, state.mmState.currentBankroll);
      return state.mmState.currentBet;
    }

    function recordResult(result) {
      if (!state.mmState.baseBet || !state.mmState.initialBankroll) {
        showMessage('Set bankroll and base bet first');
        return;
      }
      const prediction = selectPredictionAlgorithm();
      snapshots.push(JSON.parse(JSON.stringify(state)));
      const cardsDrawn = estimateCardsDrawn(result);
      state.cardCounts.low += cardsDrawn.low;
      state.cardCounts.high += cardsDrawn.high;
      state.cardCounts.totalCards += cardsDrawn.total;
      state.history.push(result);
      learnPattern(result);
      if (result === 'T' || prediction.confidence <= getDynamicConfidenceThreshold()) {
        showMessage(result === 'T' ? 'Tie recorded. No wager placed.' : `No strong prediction (confidence ‚â§ ${getDynamicConfidenceThreshold()}%). No wager placed.`);
        saveMemoryFast();
        updateDisplay();
        return;
      }
      pendingBet = { side: prediction.predict, bet: calculateNextBet() };
      document.getElementById('currentWager').innerText = `üíµ Current Bet: ${pendingBet.bet.toFixed(2)} on ${pendingBet.side === 'P' ? 'Player' : 'Banker'}`;
      showMessage(`Place bet of ${pendingBet.bet.toFixed(2)} on ${pendingBet.side === 'P' ? 'Player' : 'Banker'} and confirm result.`);
    }

    function recordWin() {
      if (!pendingBet) {
        showMessage('No pending bet to record.');
        return;
      }
      snapshots.push(JSON.parse(JSON.stringify(state)));
      const { side, bet } = pendingBet;
      const result = state.history[state.history.length - 1];
      if (result !== side) {
        showMessage(`Result (${result === 'P' ? 'Player' : 'Banker'}) does not match bet (${side === 'P' ? 'Player' : 'Banker'}). Record loss instead.`);
        return;
      }
      for (let n = 5; n >= 2; n--) {
        if (state.history.length >= n) {
          const key = state.history.slice(-n + 1).join('');
          if (state.patternMemory[key] && side === (state.patternMemory[key].P > state.patternMemory[key].B ? 'P' : 'B')) {
            state.predictionPerformance[n].total++;
            state.predictionPerformance[n].correct++;
            break;
          }
        }
      }
      state.outcomes.push('W');
      state.accuracyWindow.push('W');
      if (state.accuracyWindow.length > 10) state.accuracyWindow.shift();
      state.wins++;
      const payout = side === 'B' ? bet * (1 - state.mmState.commission / 100) : bet;
      state.mmState.currentBankroll += payout;
      state.mmState.cycleProfit += payout - bet;
      state.mmState.betHistory.push({
        id: state.mmState.betHistory.length + 1,
        mode: state.mmState.mode,
        step: state.mmState.step,
        side,
        bet,
        result: 'W',
        profitLoss: (payout - bet).toFixed(2),
        cycleProfit: state.mmState.cycleProfit.toFixed(2),
        bankroll: state.mmState.currentBankroll.toFixed(2),
        note: state.mmState.tableNotes
      });
      if (state.mmState.cycleProfit >= state.mmState.targetProfit) {
        state.mmState.cycleNumber++;
        state.mmState.cycleProfit = 0;
        state.mmState.mode = 'Base';
        state.mmState.step = 1;
        state.mmState.baseBet += state.mmState.incrementPerCycle;
      }
      pendingBet = null;
      calculateNextBet();
      saveMemoryFast();
      updateDisplay();
    }

    function recordLoss() {
      if (!pendingBet) {
        showMessage('No pending bet to record.');
        return;
      }
      snapshots.push(JSON.parse(JSON.stringify(state)));
      const { side, bet } = pendingBet;
      const result = state.history[state.history.length - 1];
      if (result === side) {
        showMessage(`Result (${result === 'P' ? 'Player' : 'Banker'}) matches bet. Record win instead.`);
        return;
      }
      for (let n = 5; n >= 2; n--) {
        if (state.history.length >= n) {
          const key = state.history.slice(-n + 1).join('');
          if (state.patternMemory[key] && side === (state.patternMemory[key].P > state.patternMemory[key].B ? 'P' : 'B')) {
            state.predictionPerformance[n].total++;
            break;
          }
        }
      }
      state.outcomes.push('L');
      state.accuracyWindow.push('L');
      if (state.accuracyWindow.length > 10) state.accuracyWindow.shift();
      state.losses++;
      state.mmState.currentBankroll -= bet;
      state.mmState.cycleProfit -= bet;
      state.mmState.betHistory.push({
        id: state.mmState.betHistory.length + 1,
        mode: state.mmState.mode,
        step: state.mmState.step,
        side,
        bet,
        result: 'L',
        profitLoss: (-bet).toFixed(2),
        cycleProfit: state.mmState.cycleProfit.toFixed(2),
        bankroll: state.mmState.currentBankroll.toFixed(2),
        note: state.mmState.tableNotes
      });
      if (state.mmState.currentBankroll <= state.mmState.stopLoss && state.mmState.stopLoss > 0) {
        state.mmState.mode = 'Base';
        state.mmState.step = 1;
        state.mmState.cycleProfit = 0;
        state.mmState.cycleNumber++;
        showMessage('Stop loss reached. Resetting to base mode.');
      } else if (state.mmState.attackMode && state.mmState.cycleProfit < 0) {
        state.mmState.step++;
        state.mmState.mode = 'Recovery';
      }
      pendingBet = null;
      calculateNextBet();
      saveMemoryFast();
      updateDisplay();
    }

    function undo() {
      if (snapshots.length) {
        const prevState = snapshots.pop();
        unlearnPattern(state.history[state.history.length - 1]);
        state = prevState;
        saveMemoryFast();
        updateDisplay();
      }
    }

    function clearAll() {
      if (confirm('Reset memory for new shoe? Bankroll and money management settings will be preserved.')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        const preservedState = {
          mmState: { ...state.mmState },
          wins: state.wins,
          losses: state.losses,
          outcomes: state.outcomes,
          selectedAlgorithms: state.selectedAlgorithms
        };
        state.history = [];
        state.patternMemory = {};
        state.predictionPerformance = { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
        state.cardCounts = { low: 0, high: 0, totalCards: 0, decks: 8 };
        state.accuracyWindow = [];
        Object.assign(state, preservedState);
        pendingBet = null;
        saveMemoryFast();
        document.getElementById('prediction').innerText = 'Waiting for input...';
        document.getElementById('shoeType').innerText = 'Detected Pattern: N/A';
        document.getElementById('historyDisplay').innerHTML = '';
        updateDisplay();
      }
    }

    function resetStats() {
      if (confirm('Reset stats (wins, losses, outcomes)?')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.wins = 0;
        state.losses = 0;
        state.outcomes = [];
        state.accuracyWindow = [];
        saveMemoryFast();
        updateDisplay();
      }
    }

    function resetMemory() {
      if (confirm('Reset learned patterns?')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.patternMemory = {};
        state.predictionPerformance = { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
        state.accuracyWindow = [];
        saveMemoryFast();
        updateDisplay();
      }
    }

    function resetBet() {
      if (confirm('Reset bet?')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.mmState.currentBet = state.mmState.baseBet;
        state.mmState.cycleProfit = 0;
        state.mmState.cycleNumber = 1;
        state.mmState.mode = 'Base';
        state.mmState.step = 1;
        state.mmState.betHistory = [];
        pendingBet = null;
        saveMemoryFast();
        updateDisplay();
      }
    }

    function forceResetCycle() {
      if (confirm('Force reset cycle?')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.mmState.cycleProfit = 0;
        state.mmState.cycleNumber++;
        state.mmState.mode = 'Base';
        state.mmState.step = 1;
        state.mmState.currentBet = state.mmState.baseBet;
        pendingBet = null;
        saveMemoryFast();
        updateDisplay();
      }
    }

    function newSession() {
      if (confirm('Start new session? All data will be reset.')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.mmState = {
          initialBankroll: 0,
          currentBankroll: 0,
          baseBet: 0,
          targetProfit: 0,
          incrementPerCycle: 0,
          commission: 5,
          stopLoss: 0,
          attackMode: false,
          currentBet: 0,
          cycleProfit: 0,
          cycleNumber: 1,
          mode: 'Base',
          step: 1,
          betHistory: [],
          tableNotes: ''
        };
        state.history = [];
        state.outcomes = [];
        state.wins = 0;
        state.losses = 0;
        state.patternMemory = {};
        state.predictionPerformance = { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
        state.cardCounts = { low: 0, high: 0, totalCards: 0, decks: 8 };
        state.accuracyWindow = [];
        pendingBet = null;
        saveMemoryFast();
        updateDisplay();
      }
    }

    function updateDisplay() {
      updatePrediction();
      updateMMDisplay();
      if (isAdmin) updateCardCountDisplay();
    }

    function updatePrediction() {
      const predDiv = document.getElementById('prediction');
      const historyDiv = document.getElementById('historyDisplay');
      historyDiv.innerHTML = '';
      const displayHistory = state.history.slice(-10);
      displayHistory.forEach((item, index) => {
        const actualIndex = state.history.length - displayHistory.length + index;
        const cell = document.createElement('div');
        cell.innerText = item;
        cell.className = item;
        if (state.outcomes[actualIndex]) {
          cell.classList.add(state.outcomes[actualIndex]);
          cell.setAttribute('data-outcome', state.outcomes[actualIndex]);
        }
        historyDiv.appendChild(cell);
      });
      const prediction = selectPredictionAlgorithm();
      if (prediction.confidence <= getDynamicConfidenceThreshold()) {
        predDiv.innerText = `Waiting for strong signal (threshold: ${getDynamicConfidenceThreshold()}%)...`;
        if (isAdmin) {
          document.getElementById('shoeType').innerText = 'Detected Pattern: N/A';
        }
        return;
      }
      if (isAdmin) {
        let sequenceLength = 0;
        for (let n = 5; n >= 2; n--) {
          if (state.history.length >= n) {
            const key = state.history.slice(-n + 1).join('');
            if (state.patternMemory[key] && prediction.predict === (state.patternMemory[key].P > state.patternMemory[key].B ? 'P' : 'B')) {
              sequenceLength = n;
              break;
            }
          }
        }
        const accuracy = state.predictionPerformance[sequenceLength].total > 0 ? 
          ((state.predictionPerformance[sequenceLength].correct / state.predictionPerformance[sequenceLength].total) * 100).toFixed(1) : 'N/A';
        const algoName = prediction.algo.charAt(0).toUpperCase() + prediction.algo.slice(1) + ' Algorithm';
        predDiv.innerText = `Prediction: ${prediction.predict === 'P' ? 'Player' : 'Banker'} (${prediction.confidence}%) [Seq: ${sequenceLength}, Acc: ${accuracy}%] Using ${algoName}`;
        let streaks = 0;
        for (let i = 1; i < state.history.length; i++) {
          if (state.history[i] === state.history[i - 1]) streaks++;
        }
        const chopScore = state.history.length > 1 ? state.history.length - 1 - streaks : 0;
        const chopRatio = state.history.length > 1 ? chopScore / (state.history.length - 1) : 0;
        let pattern = 'Balanced';
        if (chopRatio > 0.7) pattern = 'Chop';
        else if (chopRatio < 0.3) pattern = 'Streak';
        document.getElementById('shoeType').innerText = `Detected Pattern: ${pattern}`;
      } else {
        predDiv.innerText = `Prediction: ${prediction.predict === 'P' ? 'Player' : 'Banker'} (${prediction.confidence}%)`;
      }
    }

    function updateMMDisplay() {
      const { currentBankroll, cycleProfit, targetProfit, cycleNumber, mode, step, currentBet, betHistory, tableNotes, stopLoss } = state.mmState;
      document.getElementById('streakInfo').innerText = state.outcomes.slice(-3).every(v => v === 'L') ? `üßä Cold Streak` :
        state.outcomes.slice(-3).every(v => v === 'W') ? `üî• Hot Streak` : '';
      document.getElementById('currentWager').innerText = pendingBet ? 
        `üíµ Current Bet: ${pendingBet.bet.toFixed(2)} on ${pendingBet.side === 'P' ? 'Player' : 'Banker'}` : 
        `üíµ Current Bet: ${currentBet.toFixed(2)}`;
      document.getElementById('wins').innerText = state.wins;
      document.getElementById('losses').innerText = state.losses;
      document.getElementById('accuracy').innerText = state.wins + state.losses ? 
        ((state.wins / (state.wins + state.losses)) * 100).toFixed(1) + '%' : '0%';
      document.getElementById('currentBankrollDisplay').innerText = `Current Bankroll: ${currentBankroll.toFixed(2)}`;
      document.getElementById('cycleProfitDisplay').innerText = `Cycle Profit / Target: ${cycleProfit.toFixed(2)} / ${targetProfit.toFixed(2)} | Cycle #${cycleNumber}`;
      document.getElementById('modeDisplay').innerText = `Mode: ${mode} | Step ${step}`;
      document.getElementById('suggestedBetDisplay').innerText = `Suggested Next Bet: ${currentBet.toFixed(2)} (${mode} Mode)`;
      document.getElementById('bankrollInput').value = state.mmState.initialBankroll || '';
      document.getElementById('baseBetInput').value = state.mmState.baseBet || '';
      document.getElementById('targetProfitInput').value = state.mmState.targetProfit || '';
      document.getElementById('incrementInput').value = state.mmState.incrementPerCycle || '';
      document.getElementById('commissionInput').value = state.mmState.commission || '';
      document.getElementById('stopLossInput').value = state.mmState.stopLoss || '';
      document.getElementById('attackModeInput').checked = state.mmState.attackMode;
      document.getElementById('tableNotes').value = tableNotes || '';
      const mmHistoryTableBody = document.getElementById('mmHistoryTableBody');
      mmHistoryTableBody.innerHTML = '';
      betHistory.forEach(record => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${record.id}</td>
          <td>${record.mode}</td>
          <td>${record.step}</td>
          <td>${record.side}</td>
          <td>${record.bet.toFixed(2)}</td>
          <td>${record.result}</td>
          <td>${record.profitLoss}</td>
          <td>${record.cycleProfit}</td>
          <td>${record.bankroll}</td>
          <td>${record.note}</td>
        `;
        mmHistoryTableBody.appendChild(row);
      });
    }

    function saveMemoryFast() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(saveMemory, 300);
    }

    async function saveMemory() {
      try {
        const user = auth.currentUser;
        if (user) {
          await setDoc(doc(db, 'users', user.uid), {
            email: user.email,
            subscriptionEnd: (await getDoc(doc(db, 'users', user.uid))).data().subscriptionEnd,
            isAdmin: (await getDoc(doc(db, 'users', user.uid))).data().isAdmin || false,
            isOnline: true,
            state
          }, { merge: true });
        }
      } catch (e) {
        showMessage('Error saving to Firestore: ' + e.message);
      }
    }

    async function loadMemory() {
      try {
        const user = auth.currentUser;
        if (user) {
          const userDoc = await getDoc(doc(db, 'users', user.uid));
          if (userDoc.exists()) {
            const saved = userDoc.data().state || {};
            state.wins = Number(saved.wins) || 0;
            state.losses = Number(saved.losses) || 0;
            state.mmState = saved.mmState || {
              initialBankroll: 0,
              currentBankroll: 0,
              baseBet: 0,
              targetProfit: 0,
              incrementPerCycle: 0,
              commission: 5,
              stopLoss: 0,
              attackMode: false,
              currentBet: 0,
              cycleProfit: 0,
              cycleNumber: 1,
              mode: 'Base',
              step: 1,
              betHistory: [],
              tableNotes: ''
            };
            state.history = Array.isArray(saved.history) ? saved.history : [];
            state.outcomes = Array.isArray(saved.outcomes) ? saved.outcomes : [];
            state.patternMemory = saved.patternMemory || {};
            state.predictionPerformance = saved.predictionPerformance || { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
            state.cardCounts = saved.cardCounts || { low: 0, high: 0, totalCards: 0, decks: 8 };
            state.accuracyWindow = Array.isArray(saved.accuracyWindow) ? saved.accuracyWindow : [];
            state.selectedAlgorithms = isAdmin ? (Array.isArray(saved.selectedAlgorithms) ? saved.selectedAlgorithms : []) : [];
            document.getElementById('subscriptionStatus').innerText = Number.isInteger(userDoc.data().subscriptionEnd) ? 
              `Subscription: Active until ${DateTime.fromMillis(userDoc.data().subscriptionEnd, { zone: 'Asia/Manila' }).toLocaleString(DateTime.DATETIME_FULL)}` : 
              'Subscription: Invalid or not set';
            if (isAdmin) {
              document.getElementById('bayesianCheckbox').checked = state.selectedAlgorithms.includes('bayesian');
              document.getElementById('chatgptCheckbox').checked = state.selectedAlgorithms.includes('chatgpt');
              document.getElementById('grokCheckbox').checked = state.selectedAlgorithms.includes('grok');
              document.getElementById('neuralnetCheckbox').checked = state.selectedAlgorithms.includes('neuralnet');
            }
            updateDisplay();
          }
        }
      } catch (e) {
        showMessage('Error loading from Firestore: ' + e.message);
      }
    }

    function toggleAdvanced() {
      const section = document.getElementById('advancedControls');
      const button = document.querySelector('.toggle-section[onclick="toggleAdvanced()"]');
      section.classList.toggle('show');
      button.innerText = section.classList.contains('show') ? 'Hide Advanced' : 'Show Advanced';
    }

    window.signOutUser = signOutUser;
    window.createUser = createUser;
    window.updateUserSubscription = updateUserSubscription;
    window.fixUserSubscription = fixUserSubscription;
    window.extendSubscription = extendSubscription;
    window.extendSubscriptionFor = (uid, email) => {
      document.getElementById('extendUserEmail').value = email;
      document.getElementById('extendTimeUnit').value = 'hours';
      document.getElementById('extendTimeAmount').value = '';
      document.getElementById('extendTimeUnit').focus();
    };
    window.deleteUser = deleteUser;
    window.recordResult = recordResult;
    window.undo = undo;
    window.clearAll = clearAll;
    window.resetStats = resetStats;
    window.resetMemory = resetMemory;
    window.resetBet = resetBet;
    window.saveMemory = saveMemory;
    window.loadMemory = loadMemory;
    window.toggleAdvanced = toggleAdvanced;
    window.setAlgorithms = setAlgorithms;
    window.saveApplyMM = saveApplyMM;
    window.recordWin = recordWin;
    window.recordLoss = recordLoss;
    window.forceResetCycle = forceResetCycle;
    window.newSession = newSession;
  </script>
</body>
</html>
