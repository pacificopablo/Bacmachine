<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BFC VIP</title>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      padding: 20px;
      margin: 0;
      background-color: #f4f6f8;
      color: #222;
    }
    h1, h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 28px;
      color: #333;
    }
    h2 {
      font-size: 24px;
    }
    .container {
      max-width: 600px;
      margin: auto;
      background: white;
      padding: 1rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: #fff;
      transition: background 0.3s;
    }
    button:hover {
      filter: brightness(85%);
    }
    .player { background-color: #2196F3; }
    .banker { background-color: #E91E63; }
    .tie { background-color: #FFC107; }
    .clear-all { background-color: #dc3545; }
    .set-bet, .reset-bet, .mm-action, .admin-action {
      background-color: #6c757d;
    }
    .fix-subscription { background-color: #28a745; }
    .toggle-section {
      background-color: #6c757d;
      padding: 8px;
      width: 100%;
      text-align: center;
    }
    .collapsible {
      display: none;
    }
    .collapsible.show {
      display: block;
    }
    .prediction {
      font-weight: bold;
      font-size: 1.2rem;
      text-align: center;
      margin-top: 1rem;
    }
    .shoe-type, .card-count {
      text-align: center;
      font-size: 1rem;
      margin-top: 0.5rem;
      color: #555;
    }
    .history {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .history div {
      width: 40px;
      height: 30px;
      margin: 3px;
      line-height: 30px;
      text-align: center;
      color: white;
      font-weight: bold;
      border-radius: 5px;
      position: relative;
    }
    .P { background-color: #2196F3; }
    .B { background-color: #E91E63; }
    .T { background-color: #FFC107; }
    .W::after, .L::after {
      content: attr(data-outcome);
      position: absolute;
      top: -10px;
      right: -5px;
      font-size: 12px;
      color: #fff;
      background: #28a745;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
    }
    .L::after {
      background: #dc3545;
    }
    .stats {
      padding: 15px;
      text-align: center;
    }
    .section {
      text-align: center;
      margin: 12px 0;
      font-size: 18px;
      font-weight: 700;
    }
    .bet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      margin-bottom: 1rem;
      width: 100%;
      max-width: 90vw;
    }
    input[type=number], select, input[type=datetime-local], input[type=email], input[type=password], input[type=checkbox] {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      width: 150px;
    }
    label {
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .cycle-reset {
      color: #28a745;
      font-weight: 700;
    }
    .error {
      color: #dc3545;
      text-align: center;
    }
    .hidden {
      display: none;
    }
    .admin-panel table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    .admin-panel th, .admin-panel td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }
    .admin-panel th {
      background-color: #f0f0f0;
    }
    .admin-panel button {
      background-color: #dc3545;
    }
    .online-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .online { background-color: #28a745; }
    .offline { background-color: #dc3545; }
    .algorithm-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }
    @media (max-width: 500px) {
      .flex-row { flex-direction: column; align-items: stretch; }
      .bet-controls { flex-direction: column; align-items: stretch; }
      .algorithm-checkboxes { flex-direction: column; align-items: center; }
      input[type=number], input[type=datetime-local], select, input[type=email], input[type=password] { width: 100%; }
    }
  </style>
</head>
<body>
  <div id="loading" style="text-align: center; padding: 20px; font-family: 'Segoe UI', Arial, sans-serif;">Loading...</div>
  <div id="loginForm" class="container">
    <h2>Sign In</h2>
    <div class="flex-row">
      <label><span>Email</span><input type="email" id="emailInput" placeholder="Email" aria-label="Email"></label>
      <label><span>Password</span><input type="password" id="passwordInput" placeholder="Password" aria-label="Password"></label>
      <button onclick="signIn()" aria-label="Sign in">Sign In</button>
    </div>
    <div class="error" id="loginError"></div>
  </div>
  <div class="container hidden" id="appContainer">
    <h1>BFC VIP</h1>
    <div class="section" id="subscriptionStatus">Subscription: -</div>
    <div class="error" id="errorMessage"></div>
    <div class="flex-row">
      <button onclick="signOutUser()" aria-label="Sign out">Sign Out</button>
    </div>
    <div class="flex-row">
      <button class="player" onclick="recordResult('P')" aria-label="Record Player result">Player</button>
      <button class="banker" onclick="recordResult('B')" aria-label="Record Banker result">Banker</button>
      <button class="tie" onclick="recordResult('T')" aria-label="Record Tie result">Tie</button>
      <button class="clear-all" onclick="clearAll()" aria-label="Clear all data">Clear All</button>
      <button class="undo" onclick="undo()" aria-label="Undo last action">Undo</button>
    </div>
    <div class="prediction" id="prediction">Waiting for input...</div>
    <div class="shoe-type admin-only" id="shoeType">Detected Pattern: N/A</div>
    <div class="card-count admin-only" id="cardCountDisplay">Card Count: N/A</div>
    <div class="section">Showing last 10 results</div>
    <div class="history" id="historyDisplay"></div>
    <div class="stats">
      <div class="section" id="currentWager">üíµ Current Bet: 0</div>
      <div class="section" id="bankrollDisplay">üíº Balance: - | Profit: -</div>
      <div class="section" id="streakInfo"></div>
      <div class="section">
        ‚úÖ <span id="wins">0</span> | ‚ùå <span id="losses">0</span> | üìä <span id="accuracy">0%</span>
      </div>
      <div class="bet-controls">
        <label><span>Bankroll</span><input type="number" id="bankrollInput" placeholder="Bankroll" min="0.01" step="0.01" aria-label="Set bankroll"></label>
        <label><span>Unit Value</span><input type="number" id="basebetInput" placeholder="Unit Value ($)" min="0.01" step="0.01" aria-label="Set base unit"></label>
        <label>
          <select id="stopProfitType" aria-label="Select stop profit type">
            <option value="currency">$</option>
            <option value="percentage">%</option>
          </select>
          <input type="number" id="stopProfitInput" placeholder="Stop Profit" min="0" step="0.01" aria-label="Set stop profit">
        </label>
        <label>
          <span>MM System</span>
          <select id="mmSystem" aria-label="Select money management system">
            <option value="default">Default</option>
            <option value="plus1">Plus 1</option>
          </select>
        </label>
        <button class="set-bet" onclick="setBankroll()" aria-label="Set bankroll and bet">Set</button>
      </div>
      <button class="toggle-section" onclick="toggleAdvanced()" aria-label="Toggle advanced controls">Show Advanced</button>
      <div class="flex-row collapsible" id="advancedControls">
        <button class="reset-bet" onclick="resetBet()" aria-label="Reset bet">Reset Bet</button>
        <button class="mm-action" onclick="saveMemory()" aria-label="Save state">üíæ</button>
        <button class="mm-action" onclick="loadMemory()" aria-label="Load state">üì•</button>
        <button class="mm-action" onclick="resetStats()" aria-label="Reset stats">üîÑ Reset Stats</button>
        <button class="mm-action" onclick="resetMemory()" aria-label="Reset memory">üß† Reset Memory</button>
      </div>
    </div>
    <div class="admin-panel hidden" id="adminPanel">
      <h2>Admin Panel</h2>
      <div class="section">
        <h3>Create User</h3>
        <div class="flex-row">
          <label><span>Email</span><input type="email" id="newUserEmail" placeholder="Email" aria-label="New user email"></label>
          <label><span>Password</span><input type="password" id="newUserPassword" placeholder="Password" aria-label="New user password"></label>
          <label><span>Admin</span><input type="checkbox" id="newUserIsAdmin" aria-label="New user admin status"></label>
          <button class="admin-action" onclick="createUser()">Create User</button>
        </div>
      </div>
      <div class="section">
        <h3>Manage Users</h3>
        <table id="userTable">
          <thead>
            <tr>
              <th>Email</th>
              <th>Subscription End (PST)</th>
              <th>Admin</th>
              <th>Add Time</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="userTableBody"></tbody>
        </table>
      </div>
      <div class="section">
        <h3>Add Subscription Time</h3>
        <div class="flex-row">
          <label><span>User Email</span><input type="email" id="extendUserEmail" placeholder="User Email" aria-label="User email to extend subscription"></label>
          <label>
            <select id="extendTimeUnit" aria-label="Select time unit">
              <option value="hours">Hours</option>
              <option value="days">Days</option>
              <option value="test">24-Hour Test</option>
            </select>
          </label>
          <label><span>Amount</span><input type="number" id="extendTimeAmount" placeholder="Amount" min="1" step="1" aria-label="Amount of time to add"></label>
          <button class="admin-action" onclick="extendSubscription()">Add Time</button>
        </div>
      </div>
      <div class="section">
        <h3>Algorithm Selection</h3>
        <div class="flex-row algorithm-checkboxes">
          <label><input type="checkbox" id="neuralCheckbox" checked onchange="setAlgorithms()"> Neural Network</label>
          <label><input type="checkbox" id="bayesianCheckbox" checked onchange="setAlgorithms()"> Bayesian</label>
          <label><input type="checkbox" id="chatgptCheckbox" onchange="setAlgorithms()"> ChatGPT</label>
          <label><input type="checkbox" id="grokCheckbox" onchange="setAlgorithms()"> Grok</label>
        </div>
      </div>
      <div class="section">
        <h3>Online Users</h3>
        <table id="onlineUsersTable">
          <thead>
            <tr>
              <th>Email</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody id="onlineUsersTableBody"></tbody>
        </table>
      </div>
      <div class="section">
        <h3>Algorithm Accuracy</h3>
        <table id="algorithmAccuracyTable">
          <thead>
            <tr>
              <th>Email</th>
              <th>Neural</th>
              <th>Bayesian</th>
              <th>ChatGPT</th>
              <th>Grok</th>
            </tr>
          </thead>
          <tbody id="algorithmAccuracyTableBody"></tbody>
        </table>
      </div>
    </div>
  </div>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getAuth, signOut, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import { getAnalytics, logEvent } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-analytics.js';
    import { getFirestore, doc, getDoc, setDoc, collection, getDocs, query, where, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js';

    const { DateTime } = luxon;

    const firebaseConfig = {
      apiKey: "AIzaSyBs3LHGZA_8spAwQ5kgULiqcZmKqcIvZiI",
      authDomain: "bfc-vip.firebaseapp.com",
      projectId: "bfc-vip",
      storageBucket: "bfc-vip.appspot.com",
      messagingSenderId: "92211995630",
      appId: "1:92211995630:web:186a26085329fc607724ff",
      measurementId: "G-1EBPP36F59"
    };

    try {
      console.log('Initializing Firebase');
      const app = initializeApp(firebaseConfig);
      console.log('Firebase initialized');
    } catch (error) {
      console.error('Firebase init error:', error);
    }

    const auth = getAuth(app);
    const db = getFirestore(app);
    const analytics = getAnalytics(app);

    let globalSelectedAlgorithms = ['neural', 'bayesian'];
    let isAdmin = false;
    let onlineUsersUnsubscribe = null;
    let accuracyUnsubscribe = null;
    let globalSettingsUnsubscribe = null;

    let state = {
      history: [],
      outcomes: [],
      wins: 0,
      losses: 0,
      baseUnit: 0,
      startBankroll: 0,
      currentBankroll: 0,
      betState: { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] },
      stopProfitType: 'percentage',
      stopProfitValue: 0,
      stopProfitEffective: 0,
      stopProfitReached: false,
      patternMemory: {},
      predictionPerformance: { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } },
      cardCounts: { low: 0, high: 0, totalCards: 0, decks: 8 },
      accuracyWindow: [],
      altAlgoCount: 0,
      useAltAlgo: false,
      altAlgoType: 'chatgpt',
      mmSystem: 'default',
      selectedAlgorithms: ['neural', 'bayesian'],
      predictions: []
    };

    let snapshots = [];

    function showMessage(message, isLoginError = false) {
      const errorElement = isLoginError ? document.getElementById('loginError') : document.getElementById('errorMessage');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }

    function calculateTrueCount() {
      const runningCount = state.cardCounts.high - state.cardCounts.low;
      const decksRemaining = Math.max(0.5, state.cardCounts.decks - state.cardCounts.totalCards / 52);
      return runningCount / decksRemaining;
    }

    function getShoeType() {
      const history = state.history.slice(-10);
      const chops = history.filter((h, i) => i > 0 && h !== history[i-1]).length;
      const chopRatio = history.length > 1 ? chops / (history.length - 1) : 0;
      return chopRatio > 0.6 ? 'Choppy' : history.length > 3 && history.slice(-4).every(h => h === history[history.length-1]) ? 'Streaky' : 'Balanced';
    }

    function calculateCurrentStreak() {
      if (state.history.length < 2) return 0;
      let streak = 1;
      const last = state.history[state.history.length - 1];
      for (let i = state.history.length - 2; i >= 0; i--) {
        if (state.history[i] === last) streak++;
        else break;
      }
      return streak;
    }

    function calculateChopRatio() {
      let chops = 0;
      for (let i = 1; i < state.history.length; i++) {
        if (state.history[i] !== state.history[i - 1]) chops++;
      }
      return state.history.length > 1 ? chops / (state.history.length - 1) : 0;
    }

    function calculateRecentAccuracy() {
      const windowSize = Math.min(state.accuracyWindow.length, 10);
      if (windowSize === 0) return 0.5;
      const recentWins = state.accuracyWindow.slice(-windowSize).filter(o => o === 'W').length;
      return recentWins / windowSize;
    }

    function getWeightedPatternPrediction() {
      let bestPrediction = { predict: 'P', confidence: 50, score: 0 };
      for (let n = 5; n >= 2; n--) {
        if (state.history.length >= n) {
          const key = state.history.slice(-n + 1).join('');
          if (state.patternMemory[key]) {
            const p = state.patternMemory[key].P || 0;
            const b = state.patternMemory[key].B || 0;
            const total = p + b;
            if (total > 0) {
              const confidence = Math.round(100 * Math.max(p / total, b / total));
              const predict = p > b ? 'P' : 'B';
              const sequenceWeight = n / 5;
              const recencyWeight = 1 / (state.history.length - state.history.lastIndexOf(key) + 1);
              const score = sequenceWeight * recencyWeight * (confidence / 100);
              if (score > bestPrediction.score) {
                bestPrediction = { predict, confidence, score };
              }
            }
          }
        }
      }
      return bestPrediction;
    }

    function neuralNetPrediction() {
      const features = {
        streakLength: calculateCurrentStreak(),
        chopRatio: calculateChopRatio(),
        trueCount: calculateTrueCount(),
        recentAccuracy: calculateRecentAccuracy(),
        shoeType: getShoeType(),
        winRate: state.wins + state.losses > 0 ? state.wins / (state.wins + state.losses) : 0.5,
        bankrollRatio: state.currentBankroll / state.startBankroll || 1
      };

      const weights = {
        streak: 0.35,
        chop: 0.25,
        count: 0.15,
        accuracy: 0.10,
        shoeType: 0.10,
        winRate: 0.05
      };

      if (features.recentAccuracy < 0.4) {
        weights.streak *= 1.2;
        weights.chop *= 0.8;
      } else if (features.recentAccuracy > 0.6) {
        weights.chop *= 1.2;
      }

      const patternPrediction = getWeightedPatternPrediction();
      const patternConfidence = patternPrediction.confidence / 100;

      let pScore = 0, bScore = 0;

      if (features.streakLength > 2) {
        const lastOutcome = state.history[state.history.length - 1];
        if (lastOutcome === 'P') {
          pScore += features.streakLength * weights.streak;
        } else if (lastOutcome === 'B') {
          bScore += features.streakLength * weights.streak;
        }
      }

      if (features.chopRatio > 0.6) {
        const lastOutcome = state.history[state.history.length - 1];
        if (lastOutcome === 'P') {
          bScore += weights.chop * 1.5;
        } else if (lastOutcome === 'B') {
          pScore += weights.chop * 1.5;
        }
      }

      if (features.trueCount > 1) {
        bScore += features.trueCount * weights.count;
      } else if (features.trueCount < -1) {
        pScore += Math.abs(features.trueCount) * weights.count;
      }

      const accuracyFactor = features.recentAccuracy * weights.accuracy;
      pScore += accuracyFactor;
      bScore += accuracyFactor;

      if (patternPrediction.predict === 'P') {
        pScore += patternConfidence * weights.shoeType;
      } else {
        bScore += patternConfidence * weights.shoeType;
      }

      pScore *= 1 + (features.winRate - 0.5) * weights.winRate;
      bScore *= 1 + (features.winRate - 0.5) * weights.winRate;

      if (features.bankrollRatio < 0.5) {
        pScore *= 0.9;
        bScore *= 0.9;
      }

      const dynamicThreshold = 60 + 
        (features.recentAccuracy < 0.4 ? 10 : 0) + 
        (features.trueCount > 2 || features.trueCount < -2 ? 5 : 0) +
        (features.bankrollRatio < 0.3 ? 10 : 0);

      const total = pScore + bScore;
      const pConfidence = total > 0 ? Math.round((pScore / total) * 100) : 50;
      const bConfidence = total > 0 ? Math.round((bScore / total) * 100) : 50;

      if (Math.max(pConfidence, bConfidence) < dynamicThreshold) {
        return { predict: null, confidence: 0, score: 0, algo: 'neural' };
      }

      return {
        predict: pConfidence > bConfidence ? 'P' : 'B',
        confidence: Math.max(pConfidence, bConfidence),
        score: Math.abs(pConfidence - bConfidence) / 100,
        algo: 'neural'
      };
    }

    function bayesianPrediction() {
      const history = state.history.slice(-10);
      const pCount = history.filter(h => h === 'P').length;
      const bCount = history.filter(h => h === 'B').length;
      const total = pCount + bCount;
      if (total === 0) return { predict: 'P', confidence: 50, score: 0, algo: 'bayesian' };
      const pProb = pCount / total;
      const bProb = bCount / total;
      return {
        predict: pProb > bProb ? 'P' : 'B',
        confidence: Math.round(Math.max(pProb, bProb) * 100),
        score: Math.abs(pProb - bProb),
        algo: 'bayesian'
      };
    }

    function chatGPTPrediction() {
      // Placeholder: Replace with actual API call to ChatGPT if needed
      const recent = state.history.slice(-5);
      const last = recent[recent.length - 1];
      return {
        predict: last === 'P' ? 'B' : 'P', // Simple alternating pattern
        confidence: 60,
        score: 0.2,
        algo: 'chatgpt'
      };
    }

    function grokPrediction() {
      // Placeholder: Replace with actual API call to Grok if needed
      const streak = calculateCurrentStreak();
      return {
        predict: streak > 2 ? state.history[state.history.length - 1] : state.history[state.history.length - 1] === 'P' ? 'B' : 'P',
        confidence: streak > 2 ? 70 : 55,
        score: streak > 2 ? 0.3 : 0.1,
        algo: 'grok'
      };
    }

    function getDynamicConfidenceThreshold() {
      return 60 + (state.accuracyWindow.length > 10 ? state.accuracyWindow.slice(-10).filter(o => o === 'W').length / 10 * 10 : 0);
    }

    function selectPredictionAlgorithm() {
      const algorithms = isAdmin ? 
        (state.selectedAlgorithms.length > 0 ? state.selectedAlgorithms : ['neural', 'bayesian']) : 
        globalSelectedAlgorithms;

      const predictions = [];

      if (algorithms.includes('neural') && state.history.length >= 10) {
        const neuralPrediction = neuralNetPrediction();
        if (neuralPrediction.confidence >= getDynamicConfidenceThreshold()) {
          return neuralPrediction;
        }
      }

      if (algorithms.includes('bayesian')) predictions.push(bayesianPrediction());
      if (algorithms.includes('chatgpt')) predictions.push(chatGPTPrediction());
      if (algorithms.includes('grok')) predictions.push(grokPrediction());

      if (predictions.length === 0) {
        return { predict: null, confidence: 0, score: 0, algo: 'none' };
      }

      return predictions.reduce((best, current) => 
        current.confidence > best.confidence ? current : best
      );
    }

    async function setAlgorithms() {
      if (!isAdmin) return;
      const selectedAlgorithms = [];
      if (document.getElementById('neuralCheckbox').checked) selectedAlgorithms.push('neural');
      if (document.getElementById('bayesianCheckbox').checked) selectedAlgorithms.push('bayesian');
      if (document.getElementById('chatgptCheckbox').checked) selectedAlgorithms.push('chatgpt');
      if (document.getElementById('grokCheckbox').checked) selectedAlgorithms.push('grok');
      state.selectedAlgorithms = selectedAlgorithms;
      try {
        await setDoc(doc(db, 'settings', 'global'), { 
          selectedAlgorithms: selectedAlgorithms.length > 0 ? selectedAlgorithms : ['neural', 'bayesian'] 
        }, { merge: true });
        saveMemoryFast();
        updatePrediction();
        showMessage(`Selected algorithms: ${selectedAlgorithms.length > 0 ? selectedAlgorithms.join(', ') : 'Neural + Bayesian (default)'}`);
        logEvent(analytics, 'set_algorithms', { algorithms: selectedAlgorithms });
      } catch (error) {
        showMessage('Error saving algorithm selection: ' + error.message);
      }
    }

    function loadAlgorithmAccuracy() {
      if (!isAdmin) return;
      const accuracyTableBody = document.getElementById('algorithmAccuracyTableBody');
      accuracyTableBody.innerHTML = '';
      try {
        const unsubscribe = onSnapshot(collection(db, 'users'), (querySnapshot) => {
          accuracyTableBody.innerHTML = '';
          querySnapshot.forEach(doc => {
            const user = doc.data();
            if (user.deleted) return;
            const state = user.state || {};
            const predictionPerformance = state.predictionPerformance || { 
              2: { correct: 0, total: 0 }, 
              3: { correct: 0, total: 0 }, 
              4: { correct: 0, total: 0 }, 
              5: { correct: 0, total: 0 } 
            };
            const accuracyWindow = state.accuracyWindow || [];
            const altAlgoType = state.altAlgoType || 'chatgpt';

            let neuralCorrect = 0, neuralTotal = 0;
            let bayesianCorrect = 0, bayesianTotal = 0;
            let chatgptCorrect = 0, chatgptTotal = 0;
            let grokCorrect = 0, grokTotal = 0;

            accuracyWindow.forEach((outcome, index) => {
              const prediction = state.predictions?.[index] || {};
              if (prediction.algo === 'neural') {
                neuralTotal++;
                if (outcome === 'W') neuralCorrect++;
              } else if (prediction.algo === 'bayesian') {
                bayesianTotal++;
                if (outcome === 'W') bayesianCorrect++;
              } else if (prediction.algo === 'chatgpt') {
                chatgptTotal++;
                if (outcome === 'W') chatgptCorrect++;
              } else if (prediction.algo === 'grok') {
                grokTotal++;
                if (outcome === 'W') grokCorrect++;
              }
            });

            const neuralAccuracy = neuralTotal > 0 ? (neuralCorrect / neuralTotal * 100).toFixed(1) + '%' : 'N/A';
            const bayesianAccuracy = bayesianTotal > 0 ? (bayesianCorrect / bayesianTotal * 100).toFixed(1) + '%' : 'N/A';
            const chatgptAccuracy = chatgptTotal > 0 ? (chatgptCorrect / chatgptTotal * 100).toFixed(1) + '%' : 'N/A';
            const grokAccuracy = grokTotal > 0 ? (grokCorrect / grokTotal * 100).toFixed(1) + '%' : 'N/A';

            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${user.email}</td>
              <td>${neuralAccuracy}</td>
              <td>${bayesianAccuracy}</td>
              <td>${chatgptAccuracy}</td>
              <td>${grokAccuracy}</td>
            `;
            accuracyTableBody.appendChild(row);
          });
        });
        return unsubscribe;
      } catch (error) {
        showMessage('Error loading algorithm accuracy: ' + error.message);
      }
    }

    function loadOnlineUsers() {
      if (!isAdmin) return;
      const onlineUsersTableBody = document.getElementById('onlineUsersTableBody');
      onlineUsersTableBody.innerHTML = '';
      try {
        const unsubscribe = onSnapshot(collection(db, 'users'), (querySnapshot) => {
          onlineUsersTableBody.innerHTML = '';
          querySnapshot.forEach(doc => {
            const user = doc.data();
            if (user.deleted) return;
            const isOnline = user.lastActive && DateTime.now().toMillis() - user.lastActive < 5 * 60 * 1000;
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${user.email}</td>
              <td><span class="online-indicator ${isOnline ? 'online' : 'offline'}"></span>${isOnline ? 'Online' : 'Offline'}</td>
            `;
            onlineUsersTableBody.appendChild(row);
          });
        });
        return unsubscribe;
      } catch (error) {
        showMessage('Error loading online users: ' + error.message);
      }
    }

    function loadUsers() {
      if (!isAdmin) return;
      const userTableBody = document.getElementById('userTableBody');
      userTableBody.innerHTML = '';
      try {
        const unsubscribe = onSnapshot(collection(db, 'users'), (querySnapshot) => {
          userTableBody.innerHTML = '';
          querySnapshot.forEach(doc => {
            const user = doc.data();
            if (user.deleted) return;
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${user.email}</td>
              <td>${user.subscriptionEnd ? DateTime.fromMillis(user.subscriptionEnd).toLocaleString(DateTime.DATETIME_SHORT) : 'N/A'}</td>
              <td>${user.isAdmin ? 'Yes' : 'No'}</td>
              <td><button onclick="updateUserSubscription('${doc.id}', '${user.email}')" aria-label="Extend subscription">Add</button></td>
              <td>
                <button class="fix-subscription" onclick="fixUserSubscription('${doc.id}')" aria-label="Fix subscription">Fix</button>
                <button onclick="deleteUser('${doc.id}')" aria-label="Delete user">Delete</button>
              </td>
            `;
            userTableBody.appendChild(row);
          });
        });
        return unsubscribe;
      } catch (error) {
        showMessage('Error loading users: ' + error.message);
      }
    }

    async function loadMemory() {
      try {
        const user = auth.currentUser;
        if (user) {
          const userDoc = await getDoc(doc(db, 'users', user.uid));
          if (userDoc.exists()) {
            const saved = userDoc.data().state || {};
            state = {
              ...state,
              ...saved,
              predictions: Array.isArray(saved.predictions) ? saved.predictions : [],
              history: Array.isArray(saved.history) ? saved.history : [],
              outcomes: Array.isArray(saved.outcomes) ? saved.outcomes : [],
              accuracyWindow: Array.isArray(saved.accuracyWindow) ? saved.accuracyWindow : []
            };
            updateUI();
            updatePrediction();
            updateShoeInfo();
          }
        }
      } catch (e) {
        showMessage('Error loading from Firestore: ' + e.message);
      }
    }

    async function saveMemoryFast() {
      try {
        const user = auth.currentUser;
        if (user) {
          await setDoc(doc(db, 'users', user.uid), {
            state,
            lastActive: DateTime.now().toMillis()
          }, { merge: true });
        }
      } catch (e) {
        console.error('Error saving to Firestore:', e);
      }
    }

    function updatePrediction() {
      const prediction = selectPredictionAlgorithm();
      document.getElementById('prediction').textContent = prediction.predict 
        ? `Prediction: ${prediction.predict} (${prediction.confidence}% - ${prediction.algo})` 
        : 'Waiting for input...';
    }

    function updateShoeInfo() {
      document.getElementById('shoeType').textContent = `Detected Pattern: ${getShoeType()}`;
      document.getElementById('cardCountDisplay').textContent = `Card Count: ${calculateTrueCount().toFixed(2)}`;
    }

    function updateUI() {
      document.getElementById('historyDisplay').innerHTML = state.history.slice(-10).map((h, i) => {
        const outcome = state.accuracyWindow[i] || '';
        return `<div class="${h}" data-outcome="${outcome}">${h}</div>`;
      }).join('');
      document.getElementById('wins').textContent = state.wins;
      document.getElementById('losses').textContent = state.losses;
      document.getElementById('accuracy').textContent = state.wins + state.losses > 0 
        ? `${((state.wins / (state.wins + state.losses)) * 100).toFixed(1)}%` 
        : '0%';
      document.getElementById('currentWager').textContent = `üíµ Current Bet: ${state.betState.currentBetUnits * state.baseUnit || 0}`;
      document.getElementById('bankrollDisplay').textContent = `üíº Balance: ${state.currentBankroll || 0} | Profit: ${state.betState.totalProfit || 0}`;
      document.getElementById('streakInfo').textContent = `Current Streak: ${calculateCurrentStreak()} (${getShoeType()})`;
    }

    function recordResult(result) {
      if (!state.baseUnit || !state.startBankroll) {
        showMessage('Set bankroll/unit first');
        return;
      }
      const prediction = selectPredictionAlgorithm();
      snapshots.push(JSON.parse(JSON.stringify(state)));
      if (!state.predictions) state.predictions = [];
      state.predictions.push({
        algo: prediction.algo,
        predict: prediction.predict,
        confidence: prediction.confidence,
        timestamp: DateTime.now().toMillis()
      });
      state.history.push(result);
      state.outcomes.push(prediction.predict === result ? 'W' : 'L');
      state.accuracyWindow.push(prediction.predict === result ? 'W' : 'L');
      if (prediction.predict === result && result !== 'T') {
        state.wins++;
        state.currentBankroll += state.betState.currentBetUnits * state.baseUnit * (result === 'B' ? 0.95 : 1);
        state.betState.totalProfit += state.betState.currentBetUnits * state.baseUnit * (result === 'B' ? 0.95 : 1);
        state.betState.cycleProfit += state.betState.currentBetUnits * state.baseUnit * (result === 'B' ? 0.95 : 1);
      } else if (result !== 'T') {
        state.losses++;
        state.currentBankroll -= state.betState.currentBetUnits * state.baseUnit;
        state.betState.totalProfit -= state.betState.currentBetUnits * state.baseUnit;
        state.betState.cycleProfit -= state.betState.currentBetUnits * state.baseUnit;
        state.betState.previousLosses.push(state.betState.currentBetUnits);
      }
      if (state.mmSystem === 'plus1' && prediction.predict === result && result !== 'T') {
        state.betState.currentBetUnits++;
      } else if (state.betState.previousLosses.length > 0) {
        state.betState.currentBetUnits = state.betState.previousLosses.pop();
      }
      // Update card counts (simplified)
      state.cardCounts.totalCards += 4; // Assume 4 cards per hand
      if (['2','3','4','5'].includes(result)) state.cardCounts.low++;
      if (['10','J','Q','K','A'].includes(result)) state.cardCounts.high++;
      // Update pattern memory
      for (let n = 2; n <= 5; n++) {
        if (state.history.length >= n) {
          const key = state.history.slice(-n).join('');
          state.patternMemory[key] = state.patternMemory[key] || { P: 0, B: 0 };
          if (result === 'P') state.patternMemory[key].P++;
          if (result === 'B') state.patternMemory[key].B++;
          state.predictionPerformance[n].total++;
          if (prediction.predict === result) state.predictionPerformance[n].correct++;
        }
      }
      // Check stop profit
      if (state.stopProfitType === 'percentage' && state.betState.totalProfit >= state.startBankroll * (state.stopProfitValue / 100)) {
        state.stopProfitReached = true;
        showMessage('Stop profit reached!');
      } else if (state.stopProfitType === 'currency' && state.betState.totalProfit >= state.stopProfitValue) {
        state.stopProfitReached = true;
        showMessage('Stop profit reached!');
      }
      updateUI();
      updatePrediction();
      updateShoeInfo();
      saveMemoryFast();
    }

    function undo() {
      if (snapshots.length > 0) {
        state = snapshots.pop();
        updateUI();
        updatePrediction();
        updateShoeInfo();
        saveMemoryFast();
      }
    }

    function clearAll() {
      if (confirm('Reset memory for new shoe? Bankroll, wager, profit, and money management will be preserved.')) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        const preservedState = {
          baseUnit: state.baseUnit,
          startBankroll: state.startBankroll,
          currentBankroll: state.currentBankroll,
          betState: state.betState,
          stopProfitType: state.stopProfitType,
          stopProfitValue: state.stopProfitValue,
          stopProfitEffective: state.stopProfitEffective,
          stopProfitReached: state.stopProfitReached,
          mmSystem: state.mmSystem,
          selectedAlgorithms: state.selectedAlgorithms,
          predictions: state.predictions
        };
        state = {
          ...state,
          history: [],
          outcomes: [],
          wins: 0,
          losses: 0,
          patternMemory: {},
          predictionPerformance: { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } },
          cardCounts: { low: 0, high: 0, totalCards: 0, decks: 8 },
          accuracyWindow: []
        };
        Object.assign(state, preservedState);
        updateUI();
        updatePrediction();
        updateShoeInfo();
        saveMemoryFast();
      }
    }

    function resetStats() {
      snapshots.push(JSON.parse(JSON.stringify(state)));
      state.wins = 0;
      state.losses = 0;
      state.accuracyWindow = [];
      updateUI();
      updatePrediction();
      saveMemoryFast();
    }

    function resetMemory() {
      snapshots.push(JSON.parse(JSON.stringify(state)));
      state.patternMemory = {};
      state.predictionPerformance = { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
      state.cardCounts = { low: 0, high: 0, totalCards: 0, decks: 8 };
      updateUI();
      updatePrediction();
      updateShoeInfo();
      saveMemoryFast();
    }

    function setBankroll() {
      const bankrollInput = document.getElementById('bankrollInput').value;
      const basebetInput = document.getElementById('basebetInput').value;
      const stopProfitType = document.getElementById('stopProfitType').value;
      const stopProfitInput = document.getElementById('stopProfitInput').value;
      if (bankrollInput && basebetInput) {
        snapshots.push(JSON.parse(JSON.stringify(state)));
        state.startBankroll = parseFloat(bankrollInput);
        state.currentBankroll = state.startBankroll;
        state.baseUnit = parseFloat(basebetInput);
        state.stopProfitType = stopProfitType;
        state.stopProfitValue = parseFloat(stopProfitInput) || 0;
        state.mmSystem = document.getElementById('mmSystem').value;
        state.betState.totalProfit = 0;
        state.betState.cycleProfit = 0;
        state.betState.previousLosses = [];
        state.betState.currentBetUnits = 1;
        state.stopProfitReached = false;
        updateUI();
        saveMemoryFast();
        showMessage('Bankroll and bet set.');
      } else {
        showMessage('Please enter valid bankroll and unit values.');
      }
    }

    function resetBet() {
      snapshots.push(JSON.parse(JSON.stringify(state)));
      state.betState.currentBetUnits = 1;
      state.betState.previousLosses = [];
      updateUI();
      saveMemoryFast();
      showMessage('Bet reset.');
    }

    async function saveMemory() {
      await saveMemoryFast();
      showMessage('State saved successfully.');
    }

    function toggleAdvanced() {
      const advancedControls = document.getElementById('advancedControls');
      advancedControls.classList.toggle('show');
    }

    async function signIn() {
      const email = document.getElementById('emailInput').value;
      const password = document.getElementById('passwordInput').value;
      try {
        await signInWithEmailAndPassword(auth, email, password);
        document.getElementById('loginForm').classList.add('hidden');
        document.getElementById('appContainer').classList.remove('hidden');
      } catch (error) {
        showMessage('Sign-in error: ' + error.message, true);
      }
    }

    async function signOutUser() {
      try {
        await signOut(auth);
        document.getElementById('appContainer').classList.add('hidden');
        document.getElementById('loginForm').classList.remove('hidden');
        showMessage('Signed out successfully.');
      } catch (error) {
        showMessage('Error signing out: ' + error.message);
      }
    }

    async function createUser() {
      if (!isAdmin) {
        showMessage('Admin access required.');
        return;
      }
      const email = document.getElementById('newUserEmail').value;
      const password = document.getElementById('newUserPassword').value;
      const isAdmin = document.getElementById('newUserIsAdmin').checked;
      try {
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        await setDoc(doc(db, 'users', userCredential.user.uid), {
          email,
          isAdmin,
          subscriptionEnd: null,
          state: {},
          lastActive: DateTime.now().toMillis()
        });
        showMessage('User created successfully.');
      } catch (error) {
        showMessage('Error creating user: ' + error.message);
      }
    }

    async function extendSubscription() {
      if (!isAdmin) {
        showMessage('Admin access required.');
        return;
      }
      const email = document.getElementById('extendUserEmail').value;
      const timeUnit = document.getElementById('extendTimeUnit').value;
      const amount = parseInt(document.getElementById('extendTimeAmount').value);
      if (!email || !amount) {
        showMessage('Please enter a valid email and amount.');
        return;
      }
      try {
        const q = query(collection(db, 'users'), where('email', '==', email));
        const querySnapshot = await getDocs(q);
        if (querySnapshot.empty) {
          showMessage('User not found.');
          return;
        }
        const userDoc = querySnapshot.docs[0];
        const userData = userDoc.data();
        let newEnd = userData.subscriptionEnd ? DateTime.fromMillis(userData.subscriptionEnd) : DateTime.now();
        if (timeUnit === 'hours') {
          newEnd = newEnd.plus({ hours: amount });
        } else if (timeUnit === 'days') {
          newEnd = newEnd.plus({ days: amount });
        } else if (timeUnit === 'test') {
          newEnd = DateTime.now().plus({ hours: 24 });
        }
        await setDoc(doc(db, 'users', userDoc.id), { subscriptionEnd: newEnd.toMillis() }, { merge: true });
        showMessage(`Subscription extended for ${email}.`);
      } catch (error) {
        showMessage('Error extending subscription: ' + error.message);
      }
    }

    async function fixUserSubscription(uid) {
      if (!isAdmin) {
        showMessage('Admin access required.');
        return;
      }
      try {
        await setDoc(doc(db, 'users', uid), { subscriptionEnd: DateTime.now().plus({ days: 7 }).toMillis() }, { merge: true });
        showMessage('Subscription fixed for 7 days.');
      } catch (error) {
        showMessage('Error fixing subscription: ' + error.message);
      }
    }

    async function deleteUser(uid) {
      if (!isAdmin) {
        showMessage('Admin access required.');
        return;
      }
      if (confirm('Are you sure you want to delete this user?')) {
        try {
          await setDoc(doc(db, 'users', uid), { deleted: true }, { merge: true });
          showMessage('User marked as deleted.');
        } catch (error) {
          showMessage('Error deleting user: ' + error.message);
        }
      }
    }

    onAuthStateChanged(auth, async user => {
      const loading = document.getElementById('loading');
      const appContainer = document.getElementById('appContainer');
      const loginForm = document.getElementById('loginForm');
      try {
        console.log('Auth state changed:', user ? user.uid : 'No user');
        loading.style.display = 'block';
        if (user) {
          const userDoc = await getDoc(doc(db, 'users', user.uid));
          if (userDoc.exists()) {
            const userData = userDoc.data();
            if (userData.deleted) {
              showMessage('Account deleted. Please contact support.');
              loginForm.classList.remove('hidden');
              appContainer.classList.add('hidden');
              return;
            }
            isAdmin = userData.isAdmin || false;
            state = {
              ...state,
              ...userData.state,
              predictions: Array.isArray(userData.state?.predictions) ? userData.state.predictions : [],
              history: Array.isArray(userData.state?.history) ? userData.state.history : [],
              outcomes: Array.isArray(userData.state?.outcomes) ? userData.state.outcomes : [],
              accuracyWindow: Array.isArray(userData.state?.accuracyWindow) ? userData.state.accuracyWindow : []
            };
            loginForm.classList.add('hidden');
            appContainer.classList.remove('hidden');
            document.getElementById('adminPanel').classList.toggle('hidden', !isAdmin);
            document.getElementById('shoeType').classList.toggle('hidden', !isAdmin);
            document.getElementById('cardCountDisplay').classList.toggle('hidden', !isAdmin);
            document.getElementById('subscriptionStatus').textContent = `Subscription: ${userData.subscriptionEnd ? DateTime.fromMillis(userData.subscriptionEnd).toLocaleString(DateTime.DATETIME_SHORT) : 'N/A'}`;
            await loadMemory();
            updatePrediction();
            updateUI();
            updateShoeInfo();
            if (isAdmin) {
              accuracyUnsubscribe = loadAlgorithmAccuracy();
              onlineUsersUnsubscribe = loadOnlineUsers();
              loadUsers();
              globalSettingsUnsubscribe = onSnapshot(doc(db, 'settings', 'global'), (doc) => {
                if (doc.exists()) {
                  globalSelectedAlgorithms = doc.data().selectedAlgorithms || ['neural', 'bayesian'];
                  updatePrediction();
                }
              });
            }
          } else {
            showMessage('User data not found.');
            loginForm.classList.remove('hidden');
            appContainer.classList.add('hidden');
          }
        } else {
          loginForm.classList.remove('hidden');
          appContainer.classList.add('hidden');
          showMessage('Please sign in to access the app.', true);
        }
      } catch (error) {
        console.error('Initialization error:', error);
        showMessage('Error loading app: ' + error.message);
        loginForm.classList.remove('hidden');
        appContainer.classList.add('hidden');
      } finally {
        loading.style.display = 'none';
      }
    });

    window.signIn = signIn;
    window.signOutUser = signOutUser;
    window.createUser = createUser;
    window.updateUserSubscription = (uid, email) => {
      document.getElementById('extendUserEmail').value = email;
      document.getElementById('extendTimeUnit').value = 'hours';
      document.getElementById('extendTimeAmount').value = '';
      document.getElementById('extendTimeUnit').focus();
    };
    window.fixUserSubscription = fixUserSubscription;
    window.extendSubscription = extendSubscription;
    window.deleteUser = deleteUser;
    window.recordResult = recordResult;
    window.undo = undo;
    window.clearAll = clearAll;
    window.resetStats = resetStats;
    window.resetMemory = resetMemory;
    window.setBankroll = setBankroll;
    window.resetBet = resetBet;
    window.saveMemory = saveMemory;
    window.loadMemory = loadMemory;
    window.toggleAdvanced = toggleAdvanced;
    window.setAlgorithms = setAlgorithms;
  </script>
</body>
</html>
