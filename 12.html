<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ... (keep existing head section unchanged) ... -->
</head>
<body>
  <div class="container hidden" id="appContainer">
    <!-- ... (keep existing HTML structure unchanged until the MM System dropdown) ... -->
    
    <div class="bet-controls">
      <label><span>Bankroll</span><input type="number" id="bankrollInput" placeholder="Bankroll" min="0.01" step="0.01" aria-label="Set bankroll"></label>
      <label><span>Unit Value</span><input type="number" id="basebetInput" placeholder="Unit Value ($)" min="0.01" step="0.01" aria-label="Set base unit"></label>
      <label>
        <select id="stopProfitType" aria-label="Select stop profit type">
          <option value="currency">$</option>
          <option value="percentage">%</option>
        </select>
        <input type="number" id="stopProfitInput" placeholder="Stop Profit" min="0" step="0.01" aria-label="Set stop profit">
      </label>
      <label>
        <span>MM System</span>
        <select id="mmSystem" aria-label="Select money management system">
          <option value="default">Default</option>
          <option value="plus1">Plus 1</option>
          <option value="bank4">Bank4</option>
        </select>
      </label>
      <button class="set-bet" onclick="setBankroll()" aria-label="Set bankroll and bet">Set</button>
    </div>
    
    <!-- ... (keep rest of HTML structure unchanged) ... -->
  </div>

  <script type="module">
    // ... (keep all Firebase initialization code unchanged) ...
    
    let state = {
      history: [],
      outcomes: [],
      wins: 0,
      losses: 0,
      baseUnit: 0,
      startBankroll: 0,
      currentBankroll: 0,
      betState: { 
        currentBetUnits: 1, 
        totalProfit: 0, 
        cycleProfit: 0, 
        previousLosses: [],
        // Bank4 specific properties
        baseLossStreak: 0,
        recoverySteps: [2, 3, 4, 6],
        recoveryIndex: 0,
        attackSteps: [1, 2, 4],
        attackIndex: 0,
        attackActive: false,
        mode: 'Base',
        targetProfit: 3,
        increment: 0
      },
      stopProfitType: 'percentage',
      stopProfitValue: 0,
      stopProfitEffective: 0,
      stopProfitReached: false,
      patternMemory: {},
      predictionPerformance: { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } },
      cardCounts: { low: 0, high: 0, totalCards: 0, decks: 8 },
      accuracyWindow: [],
      altAlgoCount: 0,
      useAltAlgo: false,
      altAlgoType: 'chatgpt',
      mmSystem: 'default',
      attackMode: 'on',
      selectedAlgorithms: []
    };

    // ... (keep all existing functions unchanged until handleWin/handleLoss) ...

    function nextBetAmount() {
      if (state.mmSystem !== 'bank4') return state.baseUnit * state.betState.currentBetUnits;
      
      if (state.betState.mode === 'Base') return state.baseUnit;
      if (state.betState.mode === 'Recovery') return state.baseUnit * state.betState.recoverySteps[state.betState.recoveryIndex];
      if (state.betState.mode === 'Attack') return state.baseUnit * state.betState.attackSteps[state.betState.attackIndex];
      return state.baseUnit;
    }

    function stepBadges() {
      if (state.mmSystem !== 'bank4') return { mode: '', step: '', note: '' };
      
      if (state.betState.mode === 'Base') {
        return {
          mode: 'Base',
          step: `Step ${Math.min(state.betState.baseLossStreak + 1, 3)}`,
          note: 'Base Mode'
        };
      } else if (state.betState.mode === 'Recovery') {
        return {
          mode: 'Recovery',
          step: `Step ${state.betState.recoveryIndex + 1}/${state.betState.recoverySteps.length}`,
          note: 'Mild progression 2-3-4-6'
        };
      } else if (state.betState.mode === 'Attack') {
        return {
          mode: 'Attack',
          step: `Step ${state.betState.attackIndex + 1}/${state.betState.attackSteps.length}`,
          note: 'Mini-parlay 1→2→4'
        };
      }
      return { mode: 'Base', step: 'Step 1', note: '' };
    }

    function resetCycle(manual = false) {
      if (state.mmSystem !== 'bank4') {
        state.betState.cycleProfit = 0;
        return;
      }
      
      state.betState.cycleProfit = 0;
      state.betState.mode = 'Base';
      state.betState.baseLossStreak = 0;
      state.betState.recoveryIndex = 0;
      state.betState.attackIndex = 0;
      state.betState.attackActive = false;
      if (!manual) {
        state.betState.targetProfit += state.betState.increment;
      }
    }

    function handleWin() {
      const wager = nextBetAmount();
      const payout = state.history[state.history.length - 1] === 'B' ? wager * 0.95 : wager;
      state.currentBankroll += payout;

      if (state.mmSystem === 'default') {
        state.betState.totalProfit += state.betState.currentBetUnits;
        state.betState.cycleProfit += state.betState.currentBetUnits;
        if (state.betState.cycleProfit >= 1) {
          state.betState.currentBetUnits = 1;
          state.betState.cycleProfit = 0;
          state.betState.previousLosses = [];
        } else {
          if (state.betState.previousLosses.length > 0) {
            state.betState.previousLosses.shift();
          }
          const lastLoss = state.betState.previousLosses.length > 0 ? state.betState.previousLosses[0] : 1;
          state.betState.currentBetUnits = lastLoss + calculatePlusX(lastLoss);
        }
      } else if (state.mmSystem === 'plus1') {
        state.betState.totalProfit += state.betState.currentBetUnits;
        state.betState.cycleProfit += state.betState.currentBetUnits;
        if (state.betState.previousLosses.length > 0) {
          state.betState.previousLosses.shift();
        }
        if (state.betState.cycleProfit >= 1) {
          state.betState.currentBetUnits = 1;
          state.betState.cycleProfit = 0;
        } else if (state.betState.previousLosses.length > 0) {
          const nextLoss = state.betState.previousLosses[0];
          state.betState.currentBetUnits = nextLoss + calculatePlusX(nextLoss);
        } else {
          state.betState.currentBetUnits = 1;
        }
      } else if (state.mmSystem === 'bank4') {
        state.betState.totalProfit += wager / state.baseUnit;
        state.betState.cycleProfit += wager / state.baseUnit;
        
        // Bank4 win logic
        if (state.betState.mode === 'Base') {
          state.betState.baseLossStreak = 0;
        } else if (state.betState.mode === 'Recovery') {
          if (state.attackMode === 'on') {
            state.betState.mode = 'Attack';
            state.betState.attackIndex = 0;
            state.betState.attackActive = true;
          } else {
            state.betState.mode = 'Base';
            state.betState.baseLossStreak = 0;
            state.betState.recoveryIndex = 0;
          }
        } else if (state.betState.mode === 'Attack') {
          if (state.betState.attackIndex < state.betState.attackSteps.length - 1) {
            state.betState.attackIndex += 1;
          } else {
            state.betState.mode = 'Base';
            state.betState.baseLossStreak = 0;
            state.betState.attackIndex = 0;
            state.betState.attackActive = false;
          }
        }
        
        if (state.betState.cycleProfit >= state.betState.targetProfit) {
          resetCycle(false);
        }
      }
    }

    function handleLoss() {
      const wager = nextBetAmount();
      state.currentBankroll -= wager;

      if (state.mmSystem === 'default') {
        state.betState.totalProfit -= state.betState.currentBetUnits;
        state.betState.cycleProfit -= state.betState.currentBetUnits;
        state.betState.previousLosses.push(state.betState.currentBetUnits);
      } else if (state.mmSystem === 'plus1') {
        state.betState.totalProfit -= state.betState.currentBetUnits;
        state.betState.cycleProfit -= state.betState.currentBetUnits;
        if (state.betState.previousLosses.length === 0) {
          state.betState.previousLosses.push(state.baseUnit / state.baseUnit);
        } else {
          const nextLoss = state.betState.previousLosses[0];
          const x = calculatePlusX(nextLoss);
          state.betState.previousLosses.push(nextLoss + x);
        }
        const nextBet = state.betState.previousLosses[0];
        state.betState.currentBetUnits = nextBet + calculatePlusX(nextBet);
        if (state.betState.cycleProfit >= 1) {
          state.betState.currentBetUnits = 1;
          state.betState.cycleProfit = 0;
        }
      } else if (state.mmSystem === 'bank4') {
        state.betState.totalProfit -= wager / state.baseUnit;
        state.betState.cycleProfit -= wager / state.baseUnit;
        
        // Bank4 loss logic
        if (state.betState.mode === 'Base') {
          state.betState.baseLossStreak += 1;
          if (state.betState.baseLossStreak >= 2) {
            state.betState.mode = 'Recovery';
            state.betState.recoveryIndex = 0;
          }
        } else if (state.betState.mode === 'Recovery') {
          if (state.betState.recoveryIndex < state.betState.recoverySteps.length - 1) {
            state.betState.recoveryIndex += 1;
          } else {
            state.betState.mode = 'Base';
            state.betState.baseLossStreak = 0;
            state.betState.recoveryIndex = 0;
          }
        } else if (state.betState.mode === 'Attack') {
          state.betState.mode = 'Base';
          state.betState.baseLossStreak = 0;
          state.betState.attackIndex = 0;
          state.betState.attackActive = false;
        }
      }
    }

    function setBankroll() {
      const bankroll = parseFloat(document.getElementById('bankrollInput').value);
      const unit = parseFloat(document.getElementById('basebetInput').value);
      const stopProfit = parseFloat(document.getElementById('stopProfitInput').value) || 0;
      state.stopProfitType = document.getElementById('stopProfitType').value;
      state.mmSystem = document.getElementById('mmSystem').value;
      
      if (isNaN(bankroll) || bankroll <= 0 || isNaN(unit) || unit <= 0) {
        showMessage('Invalid bankroll or unit value');
        return;
      }
      
      snapshots.push(JSON.parse(JSON.stringify(state)));
      state.startBankroll = bankroll;
      state.baseUnit = unit;
      state.currentBankroll = bankroll;
      state.stopProfitValue = stopProfit;
      state.stopProfitEffective = state.stopProfitType === 'percentage' ? stopProfit / 100 * bankroll : stopProfit;
      state.stopProfitReached = false;
      
      // Initialize MM system specific properties
      if (state.mmSystem === 'bank4') {
        state.betState = {
          currentBetUnits: 1,
          totalProfit: 0,
          cycleProfit: 0,
          previousLosses: [],
          baseLossStreak: 0,
          recoverySteps: [2, 3, 4, 6],
          recoveryIndex: 0,
          attackSteps: [1, 2, 4],
          attackIndex: 0,
          attackActive: false,
          mode: 'Base',
          targetProfit: 3,
          increment: 0
        };
      } else {
        state.betState = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
      }
      
      state.wins = 0;
      state.losses = 0;
      state.outcomes = [];
      state.patternMemory = {};
      state.predictionPerformance = { 2: { correct: 0, total: 0 }, 3: { correct: 0, total: 0 }, 4: { correct: 0, total: 0 }, 5: { correct: 0, total: 0 } };
      state.cardCounts = { low: 0, high: 0, totalCards: 0, decks: 8 };
      state.accuracyWindow = [];
      state.altAlgoCount = 0;
      state.useAltAlgo = false;
      state.altAlgoType = 'chatgpt';
      saveMemoryFast();
      updateDisplay();
    }

    function updateMMDisplay() {
      document.getElementById('streakInfo').innerText = state.stopProfitReached ? '' : 
        state.outcomes.slice(-3).every(v => v === 'L') ? `🧊 Cold Streak - Losses: ${state.betState.previousLosses.length}` :
        state.outcomes.slice(-3).every(v => v === 'W') ? `🔥 Hot Streak` : '';
      
      document.getElementById('currentWager').innerText = `💵 Current Bet: ${getWager().toFixed(2)}`;
      document.getElementById('wins').innerText = state.wins;
      document.getElementById('losses').innerText = state.losses;
      document.getElementById('accuracy').innerText = state.wins + state.losses ? 
        ((state.wins / (state.wins + state.losses)) * 100).toFixed(1) + '%' : '0%';
      
      let previousLosses = 'None';
      let modeInfo = '';
      
      if (state.mmSystem === 'bank4') {
        const badges = stepBadges();
        modeInfo = `Mode: ${badges.mode} (${badges.step})`;
        previousLosses = state.betState.baseLossStreak;
      } else {
        previousLosses = state.betState.previousLosses.length > 0 ? 
          state.betState.previousLosses.join(', ') : 'None';
      }
      
      const stopProfitDisplay = state.stopProfitValue > 0 ? 
        state.stopProfitType === 'percentage' ? `${state.stopProfitValue}% ($${state.stopProfitEffective.toFixed(2)})` : 
        `$${state.stopProfitValue.toFixed(2)}` : 'Not Set';
        
      document.getElementById('bankrollDisplay').innerHTML = state.startBankroll ? 
        `💼 Balance: ${state.currentBankroll.toFixed(2)} | Profit: ${(state.currentBankroll - state.startBankroll).toFixed(2)}<br>` +
        `Bet: $${(nextBetAmount()).toFixed(2)} (${state.betState.currentBetUnits} units)<br>` +
        `${state.mmSystem === 'bank4' ? `Loss Streak: ${previousLosses}<br>` : `Losses: ${previousLosses}<br>`}` +
        `${state.mmSystem === 'bank4' ? modeInfo + '<br>' : ''}` +
        `<span class="${state.betState.cycleProfit >= state.betState.targetProfit ? 'cycle-reset' : ''}">` +
        `Cycle: $${(state.betState.cycleProfit * state.baseUnit).toFixed(2)}/${(state.betState.targetProfit * state.baseUnit).toFixed(2)}</span><br>` +
        `Total: $${(state.betState.totalProfit * state.baseUnit).toFixed(2)}<br>` +
        `Stop: ${stopProfitDisplay} | ${state.stopProfitReached ? '🚨 Reached' : 'Active'}<br>` +
        `MM: ${state.mmSystem === 'plus1' ? 'Plus 1' : state.mmSystem === 'bank4' ? 'Bank4' : 'Default'}` : 
        '💼 Balance: - | Profit: -';
        
      document.getElementById('bankrollInput').value = state.startBankroll || '';
      document.getElementById('basebetInput').value = state.baseUnit || '';
      document.getElementById('stopProfitType').value = state.stopProfitType;
      document.getElementById('stopProfitInput').value = state.stopProfitValue || '';
      document.getElementById('mmSystem').value = state.mmSystem;
    }

    // ... (keep all remaining existing functions unchanged) ...
  </script>
</body>
</html>
