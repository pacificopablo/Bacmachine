<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>üí∏ BFC v3.4</title>
  <style>
body{font-family:'Segoe UI',sans-serif;background:#f4f6f8;margin:0;padding:20px;color:#222}h1{text-align:center;margin-bottom:20px;font-size:28px;color:#333}.flex-row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin:10px 0}button{padding:10px 20px;border:none;background:#007bff;color:#fff;border-radius:10px;cursor:pointer;font-weight:600;transition:background .3s}button:hover{background:#0056b3}#resetBetBtn{background:#6c757d}input[type=number],select{padding:10px;font-size:16px;border:1px solid #ccc;border-radius:8px;width:150px}label{font-size:16px;display:flex;align-items:center;gap:6px}.section{text-align:center;margin:12px 0;font-size:18px;font-weight:700}.result{display:inline-block;padding:6px 14px;border-radius:8px;margin:2px;font-weight:700}.player{background:#cce4ff;color:#004085}.banker{background:#ffdada;color:#721c24}.scroll-box{max-height:300px;overflow-y:auto;background:#fff;border:1px solid #ccc;padding:12px;font-size:14px;border-radius:10px;box-shadow:0 2px 5px rgba(0,0,0,.05);margin-top:20px}.stat-box{background:#fff;border-radius:10px;padding:15px;box-shadow:0 2px 8px rgba(0,0,0,.1);display:inline-block;text-align:center;margin-top:10px}.bet-controls{margin-bottom:1rem;display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;width:100%;max-width:90vw}.cycle-reset{color:#28a745;font-weight:700}.win-streak{color:#28a745;font-weight:700}.notification{background:#ff4444;color:#fff;padding:10px;border-radius:8px;text-align:center;margin:10px auto;max-width:90%;display:none;}
  </style>
</head>
<body>
  <h1>üí∏ BFC v3.4 "Lucky is for beginners. Strategy is for winners."</h1>
  <div id="notification" class="notification"></div>
  <div class="flex-row">
    <button onclick="addResult('P')">Player</button>
    <button onclick="addResult('B')">Banker</button>
    <button onclick="undo()">Undo</button>
  </div>
  <div class="section" id="history"></div>
  <div class="section" id="prediction">AI Prediction: Waiting...</div>
  <div class="section" id="streakInfo"></div>
  <div class="section" id="currentWager">üíµ Wager: $0.00 (0 units)</div>
  <div class="section" id="bankrollDisplay">üíº Balance: - | Profit: -</div>
  <div class="flex-row">
    <input type="number" id="bankrollInput" placeholder="Bankroll">
    <input type="number" id="basebetInput" placeholder="Unit Value">
    <select id="stopProfitType">
      <option value="currency">$</option>
      <option value="percentage">%</option>
    </select>
    <input type="number" id="stopProfitInput" placeholder="Stop Profit">
    <button onclick="setBankroll()">Set</button>
  </div>
  <div class="flex-row">
    <label>Early Hands: 
      <input type="number" id="earlyHandLimit" value="10" min="5" max="20">
    </label>
  </div>
  <div class="flex-row">
    <label><input type="checkbox" id="resetOnNewShoe" checked> Reset Memory on New Shoe</label>
  </div>
  <div class="bet-controls">
    <button id="resetBetBtn" onclick="resetBet()">Reset Bet</button>
    <button onclick="startNewShoe()">New Shoe</button>
  </div>
  <div class="flex-row">
    <button onclick="saveMemory()">üíæ</button>
    <button onclick="loadMemory()">üì•</button>
    <button onclick="resetStats()">üîÑ</button>
    <button onclick="resetMemory()">üß†</button>
  </div>
  <div class="stat-box">
    ‚úÖ <span id="wins">0</span> | ‚ùå <span id="losses">0</span> | üìä <span id="accuracy">0%</span>
  </div>
  <div class="scroll-box">
    <h3>üß† Patterns</h3>
    <div id="patternMemoryBox">No patterns</div>
  </div>
  <div class="scroll-box">
    <h3>üéØ Patterns Influencing Prediction</h3>
    <div id="predictionPatternsBox">No patterns influencing prediction</div>
  </div>
  <script>
const r = [], pM = {}, pH = [], wL = [];
let w = 0, l = 0, bB = 0, sB = 0, cB = 0, sPT = 'percentage', sPV = 0, sPE = 0, sPR = false;
let predictionAccuracy = { correct: 0, total: 0 };
let bS = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] }, sT = null;

function showNotification(message) {
  const notification = document.getElementById('notification');
  notification.textContent = message;
  notification.style.display = 'block';
  setTimeout(() => { notification.style.display = 'none'; }, 3000);
}

function setBankroll() {
  try {
    const b = parseFloat(document.getElementById("bankrollInput").value);
    const u = parseFloat(document.getElementById("basebetInput").value);
    const sP = parseFloat(document.getElementById("stopProfitInput").value) || 0;
    sPT = document.getElementById("stopProfitType").value;
    if (isNaN(b) || b <= 0 || isNaN(u) || u <= 0) {
      showNotification("Invalid bankroll/unit value");
      return;
    }
    if (sP < 0) {
      showNotification("Invalid stop profit");
      return;
    }
    sB = b;
    bB = u;
    sPV = sP;
    sPE = sPT === 'percentage' ? sP / 100 * b : sP;
    cB = b;
    sPR = false;
    bS = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
    w = l = 0;
    wL.length = 0;
    predictionAccuracy = { correct: 0, total: 0 };
    updateDisplay();
  } catch (e) {
    showNotification("Error setting bankroll");
  }
}

function addResult(v) {
  try {
    if (!bB || !sB) {
      showNotification("Set bankroll/unit first");
      return;
    }
    if (sPR) {
      showNotification("Stop profit reached");
      return;
    }
    const p = hybridPrediction();
    const g = getWager();
    if (g > cB) {
      showNotification("Insufficient balance");
      return;
    }
    r.push(v);
    learn(v);
    if (p.predict !== 'None') {
      pH.push(p.predict);
      const correct = p.predict[0] === v;
      predictionAccuracy.total++;
      if (correct) predictionAccuracy.correct++;
      correct ? handleWin(p.predict) : handleLoss();
      wL.push(correct ? 'win' : 'loss');
    } else {
      pH.push(null);
      wL.push(null);
    }
    if (sPE > 0 && cB - sB >= sPE) sPR = true;
    saveMemoryFast();
    updateDisplay();
  } catch (e) {
    showNotification("Error adding result");
  }
}

function handleWin(v) {
  try {
    const u = bB;
    const payout = v === 'Banker' ? bS.currentBetUnits * 0.95 : bS.currentBetUnits;
    bS.totalProfit += payout;
    bS.cycleProfit += payout;
    cB += payout * u;
    w++;
    if (bS.cycleProfit >= 1) {
      bS.currentBetUnits = 1;
      bS.cycleProfit = 0;
      bS.previousLosses = [];
    } else {
      if (bS.previousLosses.length > 0) {
        bS.previousLosses.pop();
      }
      const lastLoss = bS.previousLosses.length > 0 ? bS.previousLosses[bS.previousLosses.length - 1] : 1;
      bS.currentBetUnits = lastLoss + 1;
    }
  } catch (e) {
    showNotification("Error handling win");
  }
}

function handleLoss() {
  try {
    const u = bB;
    bS.totalProfit -= bS.currentBetUnits;
    bS.cycleProfit -= bS.currentBetUnits;
    bS.previousLosses.push(bS.currentBetUnits);
    cB -= bS.currentBetUnits * u;
    l++;
    const lastLoss = bS.previousLosses.length > 0 ? bS.previousLosses[bS.previousLosses.length - 1] : 1;
    bS.currentBetUnits = lastLoss + 1;
  } catch (e) {
    showNotification("Error handling loss");
  }
}

function resetBet() {
  try {
    if (confirm("Reset bet?")) {
      bS = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
      updateDisplay();
    }
  } catch (e) {
    showNotification("Error resetting bet");
  }
}

function undo() {
  try {
    const v = r.pop();
    if (!v) return;
    unlearn(v);
    const p = pH.pop();
    if (p !== null) {
      const o = wL.pop();
      predictionAccuracy.total--;
      if (o === 'win') predictionAccuracy.correct--;
      const u = bB;
      if (o === 'win') {
        const payout = p === 'Banker' ? bS.currentBetUnits * 0.95 : bS.currentBetUnits;
        bS.totalProfit -= payout;
        bS.cycleProfit -= payout;
        cB -= payout * u;
        w--;
        bS.previousLosses.push(bS.currentBetUnits);
        const lastLoss = bS.previousLosses.length > 1 ? bS.previousLosses[bS.previousLosses.length - 2] : 1;
        bS.currentBetUnits = lastLoss + 1;
      } else if (o === 'loss') {
        bS.totalProfit += bS.currentBetUnits;
        bS.cycleProfit += bS.currentBetUnits;
        cB += bS.currentBetUnits * u;
        l--;
        bS.previousLosses.pop();
        const lastLoss = bS.previousLosses.length > 0 ? bS.previousLosses[bS.previousLosses.length - 1] : 1;
        bS.currentBetUnits = lastLoss + 1;
      }
    }
    sPR = sPE > 0 && cB - sB >= sPE;
    saveMemoryFast();
    updateDisplay();
  } catch (e) {
    showNotification("Error undoing action");
  }
}

function learn(v) {
  try {
    for (let n = 2; n <= 6; n++) {
      if (r.length >= n) {
        const k = r.slice(-n, -1).join('');
        if (!pM[k]) pM[k] = { P: 0, B: 0 };
        pM[k][v]++;
      }
    }
  } catch (e) {
    showNotification("Error learning pattern");
  }
}

function unlearn(v) {
  try {
    for (let n = 2; n <= 6; n++) {
      if (r.length >= n - 1) {
        const k = r.slice(-n + 1, -1).join('');
        pM[k] && (pM[k][v] = Math.max(0, pM[k][v] - 1));
      }
    }
  } catch (e) {
    showNotification("Error unlearning pattern");
  }
}

function hybridPrediction() {
  try {
    const patternVote = getPatternVote();
    return {
      predict: patternVote || 'None',
      confidence: 0
    };
  } catch (e) {
    showNotification("Error making prediction");
    return { predict: 'None', confidence: 0 };
  }
}

function getPatternVote() {
  try {
    for (let n = Math.min(6, r.length); n >= 2; n--) {
      const key = r.slice(-n + 1).join('');
      if (pM[key]) {
        const { P = 0, B = 0 } = pM[key];
        const total = P + B;
        if (total >= Math.max(3, n)) {
          const reliability = total / (n * 2);
          return P * reliability > B * reliability ? 'Player' : 'Banker';
        }
      }
    }
    return null;
  } catch (e) {
    showNotification("Error voting on pattern");
    return null;
  }
}

function getWager() {
  try {
    const prediction = hybridPrediction();
    if (!bB || prediction.predict === 'None' || sPR) return 0;
    return Math.min(bS.currentBetUnits * bB, cB);
  } catch (e) {
    showNotification("Error calculating wager");
    return 0;
  }
}

function updateDisplay() {
  try {
    document.getElementById("history").innerHTML = r.slice(-10).map(v => `<span class="result ${v === 'P' ? 'player' : 'banker'}">${v}</span>`).join('');
    const p = hybridPrediction();
    document.getElementById("prediction").innerText = sPR ? "üö® Stop Profit Reached!" : p.predict !== 'None' ? `Bet ${p.predict}` : "Waiting...";
    const winStreakLength = wL.slice().reverse().findIndex(v => v !== 'win');
    document.getElementById("streakInfo").innerHTML = sPR ? "" : wL.slice(-3).every(v => v === 'loss') ? `üßä Cold Streak - Losses: ${bS.previousLosses.length}` : winStreakLength >= 2 ? `<span class="win-streak">üî• Win Streak: ${winStreakLength === -1 ? wL.length : winStreakLength} Wins!</span>` : "";
    const wager = getWager();
    const wagerUnits = bB > 0 ? (wager / bB).toFixed(1) : 0;
    document.getElementById("currentWager").innerText = `üíµ Wager: $${wager.toFixed(2)} (${wagerUnits} units)`;
    document.getElementById("wins").innerText = w;
    document.getElementById("losses").innerText = l;
    const t = w + l;
    document.getElementById("accuracy").innerText = `${t ? (w / t * 100).toFixed(1) : 0}%`;
    const pL = bS.previousLosses.length > 0 ? bS.previousLosses.join(', ') : 'None';
    const sPD = sPV > 0 ? sPT === 'percentage' ? `${sPV}% ($${sPE.toFixed(2)})` : `$${sPV.toFixed(2)}` : 'Not Set';
    document.getElementById("bankrollDisplay").innerHTML = sB ? `üíº Balance: ${cB.toFixed(2)} | Profit: ${(cB - sB).toFixed(2)}<br>Bet: $${(bS.currentBetUnits * bB).toFixed(2)} (${bS.currentBetUnits} units)<br>Losses: ${pL}<br><span class="${bS.cycleProfit >= 1 ? 'cycle-reset' : ''}">Cycle: $${(bS.cycleProfit * bB).toFixed(2)}</span><br>Total: $${(bS.totalProfit * bB).toFixed(2)}<br>Stop: ${sPD} | ${sPR ? 'üö® Reached' : 'Active'}` : '';
    document.getElementById("patternMemoryBox").innerHTML = Object.entries(pM).map(([k, v]) => {
      const t = (v.P || 0) + (v.B || 0);
      const f = v.P > v.B ? 'Player' : v.B > v.P ? 'Banker' : 'Even';
      return `${k}‚ÜíP:${v.P || 0},B:${v.B || 0}‚Üí<b>${f}</b> (${t})<br>`;
    }).join('') || "No patterns";
    let predictionPatterns = "No patterns influencing prediction";
    if (p.predict !== 'None') {
      for (let n = Math.min(6, r.length); n >= 2; n--) {
        const key = r.slice(-n + 1).join('');
        if (pM[key]) {
          const { P = 0, B = 0 } = pM[key];
          const total = P + B;
          if (total >= Math.max(3, n)) {
            const reliability = total / (n * 2);
            predictionPatterns = `${key}‚ÜíP:${P || 0},B:${B || 0}‚Üí<b>${P * reliability > B * reliability ? 'Player' : 'Banker'}</b> (${total})`;
            break;
          }
        }
      }
    }
    document.getElementById("predictionPatternsBox").innerHTML = predictionPatterns;
  } catch (e) {
    showNotification("Error updating display");
  }
}

function saveMemoryFast() {
  try {
    clearTimeout(sT);
    sT = setTimeout(saveMemory, 300);
  } catch (e) {
    showNotification("Error scheduling save");
  }
}

async function saveMemory() {
  try {
    const data = JSON.stringify({ patterns: pM, stats: { w, l, bB, sB, cB, bS, wL, sPT, sPV, sPE, sPR, predictionAccuracy } });
    if (data.length > 5 * 1024 * 1024) {
      localStorage.clear();
      showNotification("Storage limit reached, cleared old data");
    }
    await new Promise(resolve => setTimeout(resolve, 0));
    localStorage.setItem('baccaratPatterns', JSON.stringify(pM));
    localStorage.setItem('baccaratStats', JSON.stringify({ w, l, bB, sB, cB, bS, wL, sPT, sPV, sPE, sPR, predictionAccuracy }));
  } catch (e) {
    showNotification("Failed to save to cloud");
  }
}

async function loadMemory() {
  try {
    const patterns = localStorage.getItem('baccaratPatterns');
    const stats = localStorage.getItem('baccaratStats');
    if (patterns) {
      Object.assign(pM, JSON.parse(patterns));
    }
    if (stats) {
      const s = JSON.parse(stats);
      w = Number(s.w) || 0;
      l = Number(s.l) || 0;
      bB = Number(s.bB) || 0;
      sB = Number(s.sB) || 0;
      cB = Number(s.cB) || 0;
      sPT = s.sPT || 'percentage';
      sPV = Number(s.sPV) || 0;
      sPE = Number(s.sPE) || 0;
      sPR = s.sPR || false;
      bS = s.bS || { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
      predictionAccuracy = s.predictionAccuracy || { correct: 0, total: 0 };
      Array.isArray(s.wL) && wL.push(...s.wL);
      document.getElementById("stopProfitType").value = sPT;
      document.getElementById("stopProfitInput").value = sPV || '';
    }
    updateDisplay();
  } catch (e) {
    showNotification("Failed to load from cloud, using default values");
    localStorage.clear();
    w = l = 0;
    bB = sB = cB = 0;
    sPT = 'percentage';
    sPV = sPE = 0;
    sPR = false;
    bS = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
    predictionAccuracy = { correct: 0, total: 0 };
    document.getElementById("stopProfitType").value = sPT;
    document.getElementById("stopProfitInput").value = '';
    updateDisplay();
  }
}

function resetStats() {
  try {
    if (confirm("Reset stats?")) {
      w = l = 0;
      cB = sB;
      sPT = 'percentage';
      sPV = 0;
      sPE = 0;
      sPR = false;
      bS = { currentBetUnits: 1, totalProfit: 0, cycleProfit: 0, previousLosses: [] };
      wL.length = 0;
      predictionAccuracy = { correct: 0, total: 0 };
      document.getElementById("stopProfitType").value = sPT;
      document.getElementById("stopProfitInput").value = '';
      updateDisplay();
    }
  } catch (e) {
    showNotification("Error resetting stats");
  }
}

function resetMemory() {
  try {
    if (confirm("Reset patterns?")) {
      for (let k in pM) delete pM[k];
      updateDisplay();
      saveMemoryFast();
    }
  } catch (e) {
    showNotification("Error resetting patterns");
  }
}

function startNewShoe() {
  try {
    if (confirm("Start new shoe?")) {
      if (document.getElementById("resetOnNewShoe").checked) {
        resetMemory();
      }
      r.length = 0;
      pH.length = 0;
      wL.length = 0;
      updateDisplay();
    }
  } catch (e) {
    showNotification("Error starting new shoe");
  }
}

document.addEventListener('DOMContentLoaded', () => {
  try {
    loadMemory();
  } catch (e) {
    showNotification("Error initializing app");
  }
});
  </script>
</body>
</html>
