<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>üí∏ BFC v3.5 "Money Machine"</title>
  <style>
body{font-family:'Segoe UI',sans-serif;background:#f4f6f8;margin:0;padding:20px;color:#222}h1{text-align:center;margin-bottom:20px;font-size:28px;color:#333}.flex-row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin:10px 0}button{padding:10px 20px;border:none;background:#007bff;color:#fff;border-radius:10px;cursor:pointer;font-weight:600;transition:background .3s}button:hover{background:#0056b3}#resetBetBtn{background:#6c757d}input[type=number],select{padding:10px;font-size:16px;border:1px solid #ccc;border-radius:8px;width:150px}label{font-size:16px;display:flex;align-items:center;gap:6px}.section{text-align:center;margin:12px 0;font-size:18px;font-weight:700}.result{display:inline-block;padding:6px 14px;border-radius:8px;margin:2px;font-weight:700}.player{background:#cce4ff;color:#004085}.banker{background:#ffdada;color:#721c24}.tie{background:#fff3cd;color:#856404}.scroll-box{max-height:300px;overflow-y:auto;background:#fff;border:1px solid #ccc;padding:12px;font-size:14px;border-radius:10px;box-shadow:0 2px 5px rgba(0,0,0,.05);margin-top:20px}.stat-box{background:#fff;border-radius:10px;padding:15px;box-shadow:0 2px 8px rgba(0,0,0,.1);display:inline-block;text-align:center;margin-top:10px}.bet-controls{margin-bottom:1rem;display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;width:100%;max-width:90vw}.cycle-reset{color:#28a745;font-weight:700}.win-streak{color:#28a745;font-weight:700}.confidence-bar{background:#ddd;border-radius:8px;height:10px;margin:5px 0;overflow:hidden}.confidence-fill{background:#28a745;height:100%;transition:width .3s}
#shoeStats { margin-top: 20px; }
#shoeSummary { font-size: 14px; line-height: 1.6; }
.player-prediction { color: #007bff; font-weight: 700; }
.banker-prediction { color: #dc3545; font-weight: 700; }
  </style>
</head>
<body>
  <h1>üí∏ BFC v3.5 "Money Machine"</h1>
  <div class="flex-row">
    <button onclick="addResult('P')">Player</button>
    <button onclick="addResult('B')">Banker</button>
    <button onclick="addResult('T')">Tie</button>
    <button onclick="undo()">Undo</button>
  </div>
  <div class="section" id="history"></div>
  <div class="section" id="prediction">AI Prediction: Waiting...</div>
  <div class="section" id="streakInfo"></div>
  <div class="section" id="betSuggestion"></div>
  <div class="section" id="currentWager">üíµ Wager: $0 (0 units)</div>
  <div class="section" id="bankrollDisplay">üíº Balance: - | Profit: -</div>
  <div class="flex-row">
    <input type="number" id="bankrollInput" placeholder="Bankroll">
    <input type="number" id="basebetInput" placeholder="Unit Value">
    <select id="stopProfitType">
      <option value="currency">$</option>
      <option value="percentage">%</option>
    </select>
    <input type="number" id="stopProfitInput" placeholder="Stop Profit">
    <select id="bettingStrategy">
      <option value="mm">3 Stage M.M</option>
      <option value="dlambert">D'Lembert</option>
      <option value="flatbet">Flatbet</option>
      <option value="andrei">Andrei MM</option>
    </select>
    <button onclick="setBankroll()">Set</button>
  </div>
  <div class="flex-row">
    <label>Early Hands: 
      <input type="number" id="earlyHandLimit" value="5" min="3" max="20">
    </label>
    <label>Min Confidence (%): 
      <input type="number" id="confidenceThreshold" value="10" min="0" max="100">
    </label>
  </div>
  <div class="flex-row">
    <label><input type="checkbox" id="resetOnNewShoe" checked> Reset Memory on New Shoe</label>
  </div>
  <div class="bet-controls">
    <button id="resetBetBtn" onclick="resetBet()">Reset Bet</button>
    <button onclick="startNewShoe()">New Shoe</button>
  </div>
  <div class="flex-row">
    <button onclick="saveMemory()">üíæ</button>
    <button onclick="loadMemory()">üì•</button>
    <button onclick="resetStats()">üîÑ</button>
    <button onclick="resetMemory()">üß†</button>
  </div>
  <div class="stat-box">
    ‚úÖ <span id="wins">0</span> | ‚ùå <span id="losses">0</span> | üìä <span id="accuracy">0%</span>
  </div>
  <div class="stat-box" id="shoeStats">
    <h3>üìà Shoe Statistics</h3>
    <div id="shoeSummary">No hands played</div>
  </div>
  <div class="scroll-box">
    <h3>üß† Patterns</h3>
    <div id="patternMemoryBox">No patterns</div>
  </div>
  <div class="scroll-box">
    <h3>üéØ Patterns Influencing Prediction</h3>
    <div id="predictionPatternsBox">No patterns influencing prediction</div>
  </div>
  <div class="scroll-box">
    <h3>üîó Markov Transition Probabilities</h3>
    <div id="markovMatrixBox">No transitions recorded</div>
  </div>
  <script>
const r = [], pM = {}, pH = [], wL = [], bankrollHistory = [];
let w = 0, l = 0, bB = 0, sB = 0, cB = 0, sPT = 'percentage', sPV = 0, sPE = 0, sPR = false;
let predictionAccuracy = { correct: 0, total: 0 }, volatility = 0;
let peakBankroll = 0, lowestBankroll = Infinity;
let stage = 1, level = 1, consecutiveWins = 0, consecutiveLosses = 0, paused = false, pauseHandCount = 0;
let bettingStrategy = 'mm';
let bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] }, sT = null;
let betLevels = { stage1: [], stage2: [], stage3: [] };
let dLambertUnits = 1;
let flatbetUnits = 1;
let andreiUnits = 1;
let patternAge = {};
let markovMatrix = {
  P: { P: 0, B: 0, T: 0, total: 0 },
  B: { P: 0, B: 0, T: 0, total: 0 },
  T: { P: 0, B: 0, T: 0, total: 0 }
};
let shoeStats = {
  playerCount: 0,
  bankerCount: 0,
  tieCount: 0,
  longestPlayerStreak: 0,
  longestBankerStreak: 0,
  longestChoppy: 0
};

function setBankroll() {
  try {
    const b = parseFloat(document.getElementById("bankrollInput").value);
    const u = parseFloat(document.getElementById("basebetInput").value);
    const sP = parseFloat(document.getElementById("stopProfitInput").value) || 0;
    sPT = document.getElementById("stopProfitType").value;
    bettingStrategy = document.getElementById("bettingStrategy").value;
    if (isNaN(b) || b <= 0 || isNaN(u) || u <= 0 || sP < 0) {
      return;
    }
    sB = b;
    bB = u;
    sPV = sP;
    sPE = sPT === 'percentage' ? sP / 100 * b : sP;
    cB = b;
    sPR = false;
    paused = false;
    pauseHandCount = 0;
    if (bettingStrategy === 'mm') {
      betLevels = {
        stage1: [bB, bB * 2, bB * 3],
        stage2: [bB * 4, bB * 8],
        stage3: [bB * 1.4, bB, bB * 1.2, bB * 1.6, bB * 2]
      };
      stage = 1;
      level = 0;
      bS = { cBU: betLevels.stage1[0] / bB, tP: 0, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'dlambert') {
      dLambertUnits = 1;
      bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'flatbet') {
      flatbetUnits = 1;
      bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'andrei') {
      andreiUnits = 1;
      bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    }
    consecutiveWins = 0;
    consecutiveLosses = 0;
    w = l = 0;
    wL.length = 0;
    predictionAccuracy = { correct: 0, total: 0 };
    volatility = 0;
    peakBankroll = b;
    lowestBankroll = b;
    bankrollHistory.length = 0;
    bankrollHistory.push(b);
    patternAge = {};
    markovMatrix = {
      P: { P: 0, B: 0, T: 0, total: 0 },
      B: { P: 0, B: 0, T: 0, total: 0 },
      T: { P: 0, B: 0, T: 0, total: 0 }
    };
    shoeStats = {
      playerCount: 0,
      bankerCount: 0,
      tieCount: 0,
      longestPlayerStreak: 0,
      longestBankerStreak: 0,
      longestChoppy: 0
    };
    updateDisplay();
  } catch (e) {
    return;
  }
}

function addResult(v) {
  try {
    if (!bB || !sB || sPR) {
      return;
    }
    const p = hybridPrediction();
    if (!paused && p.predict !== 'None' && p.predict !== 'Tie') {
      const g = getWager();
      if (g > cB) {
        return;
      }
    }
    if (r.length >= 2) {
      const recent = r.slice(-5).concat([v]);
      let switches = 0;
      for (let i = 1; i < recent.length; i++) {
        if (recent[i] !== recent[i - 1] && recent[i] !== 'T' && recent[i - 1] !== 'T') switches++;
      }
      volatility = switches / (recent.length - 1);
    }
    r.push(v);
    if (v === 'P') shoeStats.playerCount++;
    else if (v === 'B') shoeStats.bankerCount++;
    else if (v === 'T') shoeStats.tieCount++;
    updateShoeStats();
    learn(v);
    if (paused) {
      pauseHandCount++;
      pH.push(p.predict);
      wL.push(null);
      if (v !== 'T' && (p.predict[0] === v || pauseHandCount >= 3)) {
        paused = false;
        pauseHandCount = 0;
        if (bettingStrategy === 'andrei') {
        }
      }
    } else if (p.predict !== 'None' && p.predict !== 'Tie') {
      pH.push(p.predict);
      const correct = p.predict[0] === v;
      predictionAccuracy.total++;
      if (correct) predictionAccuracy.correct++;
      if (v === 'T') {
        handleTie();
        wL.push('tie');
      } else {
        if (correct) {
          handleWin(p.predict);
          wL.push('win');
        } else {
          handleLoss();
          wL.push('loss');
        }
      }
    } else {
      pH.push(null);
      wL.push(null);
    }
    peakBankroll = Math.max(peakBankroll, cB);
    lowestBankroll = Math.min(lowestBankroll, cB);
    bankrollHistory.push(cB);
    if (sPE > 0 && cB - sB >= sPE) sPR = true;
    saveMemoryFast();
    updateDisplay();
  } catch (e) {
    return;
  }
}

function updateShoeStats() {
  try {
    let longestPlayerStreak = 0, longestBankerStreak = 0, longestChoppy = 0;
    let currentStreak = 1, currentType = r[0], choppyCount = 0;
    for (let i = 1; i < r.length; i++) {
      if (r[i] === currentType && r[i] !== 'T') {
        currentStreak++;
      } else if (r[i] !== 'T') {
        if (currentType === 'P') longestPlayerStreak = Math.max(longestPlayerStreak, currentStreak);
        else if (currentType === 'B') longestBankerStreak = Math.max(longestBankerStreak, currentStreak);
        currentType = r[i];
        currentStreak = 1;
      }
      if (i > 0 && r[i] !== 'T' && r[i - 1] !== 'T' && r[i] !== r[i - 1]) {
        choppyCount++;
        longestChoppy = Math.max(longestChoppy, choppyCount);
      } else if (r[i] !== 'T' && r[i - 1] !== 'T') {
        choppyCount = 0;
      }
    }
    if (currentType === 'P') longestPlayerStreak = Math.max(longestPlayerStreak, currentStreak);
    else if (currentType === 'B') longestBankerStreak = Math.max(longestBankerStreak, currentStreak);
    shoeStats.longestPlayerStreak = longestPlayerStreak;
    shoeStats.longestBankerStreak = longestBankerStreak;
    shoeStats.longestChoppy = longestChoppy;
  } catch (e) {
    return;
  }
}

function handleWin(v) {
  try {
    const u = bB;
    const wU = bS.cBU;
    const p = v === 'Banker' ? wU * 0.95 : wU;
    bS.tP += p;
    bS.cP += p;
    cB += p * u;
    w++;
    consecutiveWins++;
    consecutiveLosses = 0;
    paused = false;
    pauseHandCount = 0;
    let resetCycle = bS.cP >= 1;
    if (bettingStrategy === 'mm') {
      if (resetCycle) {
        stage = 1;
        level = 0;
        bS.cBU = betLevels.stage1[0] / bB;
        bS.cP = 0;
      } else {
        if (stage === 1) {
          if (consecutiveWins >= 2) {
            stage = 3;
            level = 0;
            bS.cBU = betLevels.stage3[0] / bB;
          } else {
            level = level;
            bS.cBU = betLevels.stage1[level] / bB;
          }
        } else if (stage === 2) {
          stage = 1;
          level = 1;
          bS.cBU = betLevels.stage1[1] / bB;
        } else if (stage === 3) {
          level = (level + 1) % betLevels.stage3.length;
          bS.cBU = betLevels.stage3[level] / bB;
        }
      }
    } else if (bettingStrategy === 'dlambert') {
      if (resetCycle) {
        dLambertUnits = 1;
        bS.cBU = dLambertUnits;
        bS.cP = 0;
      } else {
        dLambertUnits = Math.max(1, dLambertUnits - 1);
        bS.cBU = dLambertUnits;
      }
    } else if (bettingStrategy === 'flatbet') {
      bS.cBU = flatbetUnits;
      if (resetCycle) {
        bS.cP = 0;
      }
    } else if (bettingStrategy === 'andrei') {
      if (resetCycle) {
        andreiUnits = 1;
        bS.cBU = 1;
        bS.cP = 0;
        bS.previousLosses = [];
      } else {
        if (bS.previousLosses.length > 0) {
          bS.previousLosses.pop();
        }
        const lastLoss = bS.previousLosses.length > 0 ? bS.previousLosses[bS.previousLosses.length - 1] : 1;
        andreiUnits = lastLoss + 1;
        bS.cBU = andreiUnits;
      }
    }
  } catch (e) {
    return;
  }
}

function handleLoss() {
  try {
    const u = bB;
    const wU = bS.cBU;
    bS.tP -= wU;
    bS.cP -= wU;
    cB -= wU * u;
    l++;
    consecutiveWins = 0;
    consecutiveLosses++;
    if (consecutiveLosses >= 3) {
      paused = true;
      pauseHandCount = 0;
      if (bettingStrategy !== 'andrei') {
        if (bettingStrategy === 'mm') {
          if (stage === 1) {
            if (consecutiveLosses >= 3) {
              stage = 2;
              level = 0;
              bS.cBU = betLevels.stage2[0] / bB;
            } else {
              level = Math.min(level + 1, 2);
              bS.cBU = betLevels.stage1[level] / bB;
            }
          } else if (stage === 2) {
            level = Math.min(level + 1, 1);
            bS.cBU = betLevels.stage2[level] / bB;
          } else if (stage === 3) {
            stage = 1;
            level = 1;
            bS.cBU = betLevels.stage1[1] / bB;
          }
        } else if (bettingStrategy === 'dlambert') {
          dLambertUnits++;
          bS.cBU = dLambertUnits;
        } else if (bettingStrategy === 'flatbet') {
          bS.cBU = flatbetUnits;
        }
      } else {
        bS.previousLosses.push(wU);
        bS.cBU = andreiUnits;
      }
    } else {
      if (bettingStrategy === 'mm') {
        if (stage === 1) {
          if (consecutiveLosses >= 3) {
            stage = 2;
            level = 0;
            bS.cBU = betLevels.stage2[0] / bB;
          } else {
            level = Math.min(level + 1, 2);
            bS.cBU = betLevels.stage1[level] / bB;
          }
        } else if (stage === 2) {
          level = Math.min(level + 1, 1);
          bS.cBU = betLevels.stage2[level] / bB;
        } else if (stage === 3) {
          stage = 1;
          level = 1;
          bS.cBU = betLevels.stage1[1] / bB;
        }
      } else if (bettingStrategy === 'dlambert') {
        dLambertUnits++;
        bS.cBU = dLambertUnits;
      } else if (bettingStrategy === 'flatbet') {
        bS.cBU = flatbetUnits;
      } else if (bettingStrategy === 'andrei') {
        bS.previousLosses.push(wU);
        bS.cBU = andreiUnits;
      }
    }
  } catch (e) {
    return;
  }
}

function handleTie() {
  try {
    consecutiveWins = 0;
    consecutiveLosses = 0;
    paused = false;
    pauseHandCount = 0;
    if (bettingStrategy === 'mm') {
      bS.cBU = betLevels.stage1[level] / bB;
    } else if (bettingStrategy === 'dlambert') {
      bS.cBU = dLambertUnits;
    } else if (bettingStrategy === 'flatbet') {
      bS.cBU = flatbetUnits;
    } else if (bettingStrategy === 'andrei') {
      bS.cBU = andreiUnits;
    }
  } catch (e) {
    return;
  }
}

function resetBet() {
  try {
    if (!confirm("Reset bet?")) {
      return;
    }
    if (bettingStrategy === 'mm') {
      stage = 1;
      level = 0;
      bS = { cBU: betLevels.stage1[0] / bB, tP: bS.tP, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'dlambert') {
      dLambertUnits = 1;
      bS = { cBU: 1, tP: bS.tP, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'flatbet') {
      flatbetUnits = 1;
      bS = { cBU: 1, tP: bS.tP, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'andrei') {
      andreiUnits = 1;
      bS = { cBU: 1, tP: bS.tP, cP: 0, previousLosses: [] };
    }
    consecutiveWins = 0;
    consecutiveLosses = 0;
    paused = false;
    pauseHandCount = 0;
    updateDisplay();
  } catch (e) {
    return;
  }
}

function undo() {
  try {
    const v = r.pop();
    if (!v) {
      return;
    }
    if (v === 'P') shoeStats.playerCount--;
    else if (v === 'B') shoeStats.bankerCount--;
    else if (v === 'T') shoeStats.tieCount--;
    updateShoeStats();
    unlearn(v);
    const p = pH.pop();
    const o = wL.pop();
    if (p !== null && o !== null) {
      predictionAccuracy.total--;
      if (o === 'win') predictionAccuracy.correct--;
      const u = bB;
      const wU = bS.cBU;
      if (o === 'win') {
        const t = p === 'Banker' ? wU * 0.95 : wU;
        bS.tP -= t;
        bS.cP -= t;
        cB -= t * u;
        w--;
        consecutiveWins--;
        consecutiveLosses = wL.slice().reverse().findIndex(x => x === 'loss') === -1 ? 0 : wL.slice().reverse().findIndex(x => x === 'loss');
        if (bettingStrategy === 'mm') {
          if (stage === 1 && level === 0 && bS.cP < 0) {
            stage = bS.previousLosses.length >= 3 ? 2 : 1;
            level = stage === 2 ? Math.min(bS.previousLosses.length - 3, 1) : Math.min(bS.previousLosses.length, 2);
            bS.cBU = stage === 1 ? betLevels.stage1[level] / bB : betLevels.stage2[level] / bB;
          } else if (stage === 1) {
            if (consecutiveWins >= 1) {
              stage = 3;
              level = betLevels.stage3.length - 1;
              bS.cBU = betLevels.stage3[level] / bB;
            } else {
              level = level;
              bS.cBU = betLevels.stage1[level] / bB;
            }
          } else if (stage === 2) {
            stage = 1;
            level = Math.min(level, 2);
            bS.cBU = betLevels.stage1[level] / bB;
          } else if (stage === 3) {
            level = (level - 1 + betLevels.stage3.length) % betLevels.stage3.length;
            bS.cBU = betLevels.stage3[level] / bB;
          }
        } else if (bettingStrategy === 'dlambert') {
          dLambertUnits = Math.min(dLambertUnits + 1, cB / u);
          bS.cBU = dLambertUnits;
        } else if (bettingStrategy === 'flatbet') {
          bS.cBU = flatbetUnits;
        } else if (bettingStrategy === 'andrei') {
          bS.previousLosses.push(wU);
          const lastLoss = bS.previousLosses.length > 1 ? bS.previousLosses[bS.previousLosses.length - 2] : 1;
          andreiUnits = lastLoss + 1;
          bS.cBU = andreiUnits;
        }
      } else if (o === 'loss') {
        bS.tP += wU;
        bS.cP += wU;
        cB += wU * u;
        l--;
        consecutiveLosses--;
        if (consecutiveLosses < 3) {
          paused = false;
          pauseHandCount = 0;
        }
        if (bettingStrategy === 'mm') {
          if (stage === 1) {
            if (consecutiveLosses >= 2) {
              stage = 2;
              level = 0;
              bS.cBU = betLevels.stage2[0] / bB;
            } else {
              level = Math.max(0, level - 1);
              bS.cBU = betLevels.stage1[level] / bB;
            }
          } else if (stage === 2) {
            level = Math.max(0, level - 1);
            bS.cBU = betLevels.stage2[level] / bB;
          } else if (stage === 3) {
            stage = 1;
            level = 0;
            bS.cBU = betLevels.stage1[0] / bB;
          }
        } else if (bettingStrategy === 'dlambert') {
          dLambertUnits = Math.max(1, dLambertUnits - 1);
          bS.cBU = dLambertUnits;
        } else if (bettingStrategy === 'flatbet') {
          bS.cBU = flatbetUnits;
        } else if (bettingStrategy === 'andrei') {
          bS.previousLosses.pop();
          const lastLoss = bS.previousLosses.length > 0 ? bS.previousLosses[bS.previousLosses.length - 1] : 1;
          andreiUnits = lastLoss + 1;
          bS.cBU = andreiUnits;
        }
      } else if (o === 'tie') {
        consecutiveWins = wL.slice().reverse().findIndex(x => x === 'win') === -1 ? 0 : wL.slice().reverse().findIndex(x => x === 'win');
        consecutiveLosses = wL.slice().reverse().findIndex(x => x === 'loss') === -1 ? 0 : wL.slice().reverse().findIndex(x => x === 'loss');
        paused = false;
        pauseHandCount = 0;
        if (bettingStrategy === 'mm') {
          bS.cBU = betLevels.stage1[level] / bB;
        } else if (bettingStrategy === 'dlambert') {
          bS.cBU = dLambertUnits;
        } else if (bettingStrategy === 'flatbet') {
          bS.cBU = flatbetUnits;
        } else if (bettingStrategy === 'andrei') {
          bS.cBU = andreiUnits;
        }
      }
    }
    bankrollHistory.pop();
    if (r.length >= 2) {
      const recent = r.slice(-5);
      let switches = 0;
      for (let i = 1; i < recent.length; i++) {
        if (recent[i] !== recent[i - 1] && recent[i] !== 'T' && recent[i - 1] !== 'T') switches++;
      }
      volatility = switches / (recent.length - 1);
    } else {
      volatility = 0;
    }
    peakBankroll = bankrollHistory.length > 0 ? Math.max(...bankrollHistory) : cB;
    lowestBankroll = bankrollHistory.length > 0 ? Math.min(...bankrollHistory) : cB;
    sPR = sPE > 0 && cB - sB >= sPE;
    saveMemoryFast();
    updateDisplay();
  } catch (e) {
    return;
  }
}

function learn(v) {
  try {
    const maxPatternLength = Math.min(3, Math.floor(r.length / 2) + 2);
    for (let n = 2; n <= maxPatternLength; n++) {
      if (r.length >= n) {
        const k = r.slice(-n, -1).join('');
        if (!pM[k]) pM[k] = { P: 0, B: 0, T: 0, lastSeen: r.length };
        pM[k][v]++;
        patternAge[k] = r.length;
      }
    }
    if (r.length >= 2) {
      const prev = r[r.length - 2];
      markovMatrix[prev][v]++;
      markovMatrix[prev].total++;
    }
    prunePatterns();
  } catch (e) {
    return;
  }
}

function unlearn(v) {
  try {
    const maxPatternLength = Math.min(3, Math.floor(r.length / 2) + 2);
    for (let n = 2; n <= maxPatternLength; n++) {
      if (r.length >= n - 1) {
        const k = r.slice(-n + 1, -1).join('');
        if (pM[k]) {
          pM[k][v] = Math.max(0, pM[k][v] - 1);
          patternAge[k] = r.length;
        }
      }
    }
    if (r.length >= 1 && r.length < markovMatrix[v].total) {
      const prev = r[r.length - 1];
      markovMatrix[prev][v] = Math.max(0, markovMatrix[prev][v] - 1);
      markovMatrix[prev].total = Math.max(0, markovMatrix[prev].total - 1);
    }
    prunePatterns();
  } catch (e) {
    return;
  }
}

function prunePatterns() {
  try {
    const decayThreshold = 200;
    const recentThreshold = 20;
    for (let k in pM) {
      const total = (pM[k].P || 0) + (pM[k].B || 0) + (pM[k].T || 0);
      const age = r.length - (patternAge[k] || 0);
      if (total < 1 || (total < 2 && age > recentThreshold) || age > decayThreshold) {
        delete pM[k];
        delete patternAge[k];
      }
    }
  } catch (e) {
    return;
  }
}

function getStreakInfo() {
  try {
    let streakType = null, streakLength = 0, isChoppy = false;
    if (r.length >= 2) {
      const recent = r.slice(-6).filter(x => x !== 'T');
      if (recent.length >= 2) {
        let switches = 0;
        for (let i = 1; i < recent.length; i++) {
          if (recent[i] !== recent[i - 1]) switches++;
        }
        isChoppy = switches / (recent.length - 1) > 0.7;
      }
      if (!isChoppy) {
        const last = r.slice(-1)[0];
        if (last !== 'T') {
          let i = r.length - 1;
          while (i >= 0 && r[i] === last && r[i] !== 'T') {
            streakLength++;
            i--;
          }
          streakType = last === 'P' ? 'Player' : last === 'B' ? 'Banker' : null;
        }
      }
    }
    return { streakType, streakLength, isChoppy };
  } catch (e) {
    return { streakType: null, streakLength: 0, isChoppy: false };
  }
}

function getMarkovPrediction() {
  try {
    if (r.length < 2) {
      return { prediction: null, confidence: 0, probabilities: {} };
    }
    const last = r[r.length - 1];
    const transitions = markovMatrix[last];
    const total = transitions.total || 1;
    const probabilities = {
      Player: transitions.P / total,
      Banker: transitions.B / total,
      Tie: transitions.T / total
    };
    const maxProb = Math.max(probabilities.Player, probabilities.Banker, probabilities.Tie);
    const prediction = maxProb === probabilities.Player ? 'Player' : maxProb === probabilities.Banker ? 'Banker' : 'Tie';
    const confidence = maxProb * Math.min(total / 5, 1);
    return { prediction, confidence, probabilities };
  } catch (e) {
    return { prediction: null, confidence: 0, probabilities: {} };
  }
}

function hybridPrediction() {
  try {
    const earlyHandLimit = parseInt(document.getElementById("earlyHandLimit").value) || 5;
    let confidenceThreshold = parseFloat(document.getElementById("confidenceThreshold").value) / 100 || 0.1;
    if (r.length >= 20) confidenceThreshold = Math.max(0.05, confidenceThreshold * 0.5);
    if (r.length < earlyHandLimit) {
      return { predict: 'None', confidence: 0, patternsUsed: [], reason: `Need ${earlyHandLimit - r.length} more hands`, markovProb: {} };
    }
    const patternVote = getPatternVote();
    const markovVote = getMarkovPrediction();
    const { streakType, streakLength, isChoppy } = getStreakInfo();
    
    let prediction = 'None';
    let confidence = 0;
    let patternsUsed = patternVote.patternsUsed || [];
    let markovProb = markovVote.probabilities || {};
    let reason = 'No strong patterns or transitions';
    
    if (patternVote.prediction && markovVote.prediction) {
      const patternWeight = 0.6;
      const markovWeight = 0.4;
      const scores = {
        Player: patternVote.prediction === 'Player' ? patternVote.confidence * patternWeight : 0 + (markovVote.prediction === 'Player' ? markovVote.confidence * markovWeight : 0),
        Banker: patternVote.prediction === 'Banker' ? patternVote.confidence * patternWeight : 0 + (markovVote.prediction === 'Banker' ? markovVote.confidence * markovWeight : 0),
        Tie: patternVote.prediction === 'Tie' ? patternVote.confidence * patternWeight : 0 + (markovVote.prediction === 'Tie' ? markovVote.confidence * markovWeight : 0)
      };
      const maxScore = Math.max(scores.Player, scores.Banker, scores.Tie);
      prediction = maxScore === scores.Player ? 'Player' : maxScore === scores.Banker ? 'Banker' : 'Tie';
      confidence = maxScore;
      reason = `Combined pattern (${patternVote.confidence.toFixed(2)}) and Markov (${markovVote.confidence.toFixed(2)})`;
    } else if (patternVote.prediction) {
      prediction = patternVote.prediction;
      confidence = patternVote.confidence;
      reason = 'Pattern-based';
    } else if (markovVote.prediction) {
      prediction = markovVote.prediction;
      confidence = markovVote.confidence;
      reason = 'Markov-based';
    }

    if (streakType && streakLength >= 3 && !isChoppy) {
      prediction = streakType;
      confidence = Math.min(confidence + 0.3, 1);
      reason = 'Following strong streak';
    } else if (isChoppy && prediction !== 'None') {
      confidence *= 0.9;
      reason = 'Choppy pattern, confidence adjusted';
    } else if (prediction === 'None' && r.length >= 2) {
      const recent = r.slice(-2).filter(x => x !== 'T');
      if (recent.length >= 2) {
        prediction = recent[0] === recent[1] ? (recent[1] === 'P' ? 'Player' : 'Banker') : (recent[1] === 'P' ? 'Banker' : 'Player');
        confidence = 0.15;
        patternsUsed = [];
        markovProb = {};
        reason = recent[0] === recent[1] ? 'Following recent repeat' : 'Reversing choppy pattern';
      } else if (recent.length === 1) {
        prediction = recent[0] === 'P' ? 'Player' : 'Banker';
        confidence = 0.15;
        patternsUsed = [];
        markovProb = {};
        reason = 'Following last outcome';
      }
    }

    if (confidence < confidenceThreshold) {
      prediction = 'None';
      confidence = 0;
      patternsUsed = [];
      markovProb = {};
      reason = `Confidence ${(confidence * 100).toFixed(1)}% below threshold`;
    }

    return { predict: prediction, confidence, patternsUsed, reason, markovProb };
  } catch (e) {
    return { predict: 'None', confidence: 0, patternsUsed: [], reason: 'Error', markovProb: {} };
  }
}

function getPatternVote() {
  try {
    let maxScore = -1;
    let prediction = null;
    let patternsUsed = [];
    const maxPatternLength = Math.min(3, Math.floor(r.length / 2) + 2);
    const historicalAccuracy = predictionAccuracy.total > 0 ? Math.min(predictionAccuracy.correct / predictionAccuracy.total, 0.9) : 0.5;

    if (r.length < 2) {
      return { prediction: null, confidence: 0, patternsUsed: [] };
    }

    for (let n = maxPatternLength; n >= 2; n--) {
      const key = r.slice(-n + 1).join('');
      if (pM[key] && pM[key].P !== undefined && pM[key].B !== undefined && pM[key].T !== undefined) {
        const { P = 0, B = 0, T = 0 } = pM[key];
        const total = P + B + T;
        if (total >= 1) {
          const reliability = Math.min(total / (n * 2), 1);
          const ageFactor = Math.max(0.5, 1 - (r.length - (patternAge[key] || r.length)) / 200);
          const lengthWeight = 0.2 * n;
          const scores = {
            Player: P * reliability * lengthWeight * ageFactor * historicalAccuracy,
            Banker: B * reliability * lengthWeight * ageFactor * historicalAccuracy,
            Tie: T * reliability * lengthWeight * ageFactor * historicalAccuracy
          };
          const maxOutcome = Math.max(scores.Player, scores.Banker, scores.Tie);
          if (maxOutcome > maxScore) {
            maxScore = maxOutcome;
            prediction = scores.Player === maxOutcome ? 'Player' : scores.Banker === maxOutcome ? 'Banker' : 'Tie';
            patternsUsed = [{ key, P, B, T, total, reliability, ageFactor, score: maxOutcome }];
          } else if (maxOutcome === maxScore) {
            patternsUsed.push({ key, P, B, T, total, reliability, ageFactor, score: maxOutcome });
          }
        }
      }
    }

    const confidence = maxScore > 0 ? Math.min(maxScore / 8, 1) : 0;
    return { prediction, confidence, patternsUsed };
  } catch (e) {
    return { prediction: null, confidence: 0, patternsUsed: [] };
  }
}

function getWager() {
  try {
    const prediction = hybridPrediction();
    if (!bB || prediction.predict === 'None' || prediction.predict === 'Tie' || sPR || paused) {
      return 0;
    }
    let wager;
    if (bettingStrategy === 'mm') {
      wager = bB * bS.cBU;
    } else if (bettingStrategy === 'dlambert') {
      wager = bB * dLambertUnits;
    } else if (bettingStrategy === 'flatbet') {
      wager = bB * flatbetUnits;
    } else if (bettingStrategy === 'andrei') {
      wager = bB * andreiUnits;
    }
    wager = Math.round(wager);
    wager = Math.min(wager, cB);
    return wager;
  } catch (e) {
    return 0;
  }
}

function updateDisplay() {
  try {
    document.getElementById("history").innerHTML = r.slice(-10).map(v => `<span class="result ${v === 'P' ? 'player' : v === 'B' ? 'banker' : 'tie'}">${v === 'P' ? 'Player' : v === 'B' ? 'Banker' : 'Tie'}</span>`).join('');
    const p = hybridPrediction();
    document.getElementById("prediction").innerHTML = sPR ? "üö® Stop Profit Reached!" : 
      paused ? `‚è∏ Paused: Waiting for win or ${3 - pauseHandCount} more hands` : 
      p.predict !== 'None' ? `Bet <span class="${p.predict === 'Player' ? 'player-prediction' : p.predict === 'Banker' ? 'banker-prediction' : ''}">${p.predict}</span> (Confidence: ${(p.confidence * 100).toFixed(1)}%)<br><small>Reason: ${p.reason}</small><div class="confidence-bar"><div class="confidence-fill" style="width:${p.confidence * 100}%"></div></div>` : 
      `Waiting... (${p.reason || 'No prediction'})`;
    document.getElementById("betSuggestion").innerText = sPR ? "" : paused ? "" : p.predict !== 'None' && p.predict !== 'Tie' ? `üéØ ${bettingStrategy === 'mm' ? `3 Stage M.M (Stage ${stage}, Level ${level + 1})` : bettingStrategy === 'dlambert' ? `D'Lembert (Bet ${dLambertUnits} units)` : bettingStrategy === 'flatbet' ? `Flatbet (Bet ${flatbetUnits} unit)` : `Andrei MM (Bet ${andreiUnits} units)`}` : "";
    const winStreakLength = wL.slice().reverse().findIndex(v => v !== 'win');
    document.getElementById("streakInfo").innerHTML = sPR ? "" : wL.slice(-3).every(v => v === 'loss') ? `üßä Cold Streak - Losses: ${l - w}` : winStreakLength >= 2 ? `<span class="win-streak">üî• Win Streak: ${winStreakLength === -1 ? wL.length : winStreakLength} Wins!</span>` : "";
    const wager = getWager();
    const wagerUnits = bB > 0 ? Math.round(wager / bB) : 0;
    document.getElementById("currentWager").innerText = `üíµ Wager: $${wager.toFixed(0)} (${wagerUnits} units)`;
    document.getElementById("wins").innerText = w;
    document.getElementById("losses").innerText = l;
    const t = w + l;
    document.getElementById("accuracy").innerText = `${t ? (w / t * 100).toFixed(1) : 0}%`;
    const sPD = sPV > 0 ? sPT === 'percentage' ? `${sPV}% ($${sPE.toFixed(2)})` : `$${sPV.toFixed(2)}` : 'Not Set';
    const absDrawdown = sB ? (sB - lowestBankroll).toFixed(2) : 0;
    const maxDrawdown = peakBankroll && peakBankroll > 0 ? ((peakBankroll - lowestBankroll) / peakBankroll * 100).toFixed(1) : 0;
    document.getElementById("bankrollDisplay").innerHTML = sB ? `üíº Balance: ${cB.toFixed(2)} | Profit: ${(cB - sB).toFixed(2)}<br>Bet: $${(bS.cBU * bB).toFixed(2)} (${bS.cBU} units)<br><span class="${bS.cP >= 0 ? 'cycle-reset' : ''}">Cycle Profit: $${(bS.cP * bB).toFixed(2)}</span><br>Total: $${(bS.tP * bB).toFixed(2)}<br>Stop: ${sPD} | ${sPR ? 'üö® Reached' : 'Active'}<br>Abs Drawdown: $${absDrawdown} | Max Drawdown: ${maxDrawdown}%` : 'üíº Balance: - | Profit: -';
    document.getElementById("patternMemoryBox").innerHTML = Object.entries(pM).map(([k, v]) => {
      const t = (v.P || 0) + (v.B || 0) + (v.T || 0);
      const f = v.P > v.B && v.P > v.T ? 'Player' : v.B > v.P && v.B > v.T ? 'Banker' : v.T > v.P && v.T > v.B ? 'Tie' : 'Even';
      const successRate = t > 0 ? Math.max(v.P, v.B, v.T) / t * 100 : 0;
      const age = r.length - (patternAge[k] || 0);
      return `${k}‚ÜíP:${v.P || 0},B:${v.B || 0},T:${v.T || 0}‚Üí<b>${f}</b> (${t}, ${successRate.toFixed(1)}%, Age: ${age})<br>`;
    }).join('') || "No patterns";
    let predictionPatterns = "No patterns influencing prediction";
    if (p.predict !== 'None') {
      predictionPatterns = p.patternsUsed.map(pat => {
        const successRate = pat.total > 0 ? Math.max(pat.P, pat.B, pat.T) / pat.total * 100 : 0;
        return `${pat.key}‚ÜíP:${pat.P || 0},B:${pat.B || 0},T:${pat.T || 0}‚Üí<b>${p.predict}</b> (${pat.total}, Reliability: ${(pat.reliability * 100).toFixed(1)}%, Score: ${pat.score.toFixed(2)})`;
      }).join('<br>');
    }
    document.getElementById("predictionPatternsBox").innerHTML = predictionPatterns;
    const markovDisplay = Object.entries(markovMatrix).map(([from, transitions]) => {
      const total = transitions.total || 1;
      return `From ${from}: P: ${(transitions.P / total * 100).toFixed(1)}%, B: ${(transitions.B / total * 100).toFixed(1)}%, T: ${(transitions.T / total * 100).toFixed(1)}% (Total: ${transitions.total})`;
    }).join('<br>');
    document.getElementById("markovMatrixBox").innerHTML = markovDisplay || "No transitions recorded";

    let shoeSummary = '';
    if (r.length > 0) {
      const totalHands = r.length;
      const playerPct = (shoeStats.playerCount / totalHands * 100).toFixed(1);
      const bankerPct = (shoeStats.bankerCount / totalHands * 100).toFixed(1);
      const tiePct = (shoeStats.tieCount / totalHands * 100).toFixed(1);
      shoeSummary += `Hands Played: ${totalHands}<br>`;
      shoeSummary += `Player: ${shoeStats.playerCount} (${playerPct}%) | Banker: ${shoeStats.bankerCount} (${bankerPct}%) | Tie: ${shoeStats.tieCount} (${tiePct}%)<br>`;
      const expectedPlayer = (totalHands * 0.4462).toFixed(1);
      const expectedBanker = (totalHands * 0.4586).toFixed(1);
      const expectedTie = (totalHands * 0.0952).toFixed(1);
      shoeSummary += `Expected: Player: ${expectedPlayer}, Banker: ${expectedBanker}, Tie: ${expectedTie}<br>`;
      shoeSummary += `Longest Streaks: Player: ${shoeStats.longestPlayerStreak}, Banker: ${shoeStats.longestBankerStreak}, Choppy: ${shoeStats.longestChoppy}<br>`;
      const bankerBias = bankerPct - 45.86;
      const playerBias = playerPct - 44.62;
      const bias = Math.abs(bankerBias) > Math.abs(playerBias) ? 
        (bankerBias > 0 ? `Banker (+${bankerBias.toFixed(1)}%)` : `Banker (${bankerBias.toFixed(1)}%)`) :
        (playerBias > 0 ? `Player (+${playerBias.toFixed(1)}%)` : `Player (${playerBias.toFixed(1)}%)`);
      shoeSummary += `Shoe Bias: ${Math.abs(bankerBias) > Math.abs(playerBias) && Math.abs(bankerBias) > 5 ? bias : 'Balanced'}`;
    } else {
      shoeSummary = 'No hands played';
    }
    document.getElementById("shoeSummary").innerHTML = shoeSummary;
  } catch (e) {
    return;
  }
}

function saveMemoryFast() {
  try {
    clearTimeout(sT);
    sT = setTimeout(saveMemory, 300);
  } catch (e) {
    return;
  }
}

async function saveMemory() {
  try {
    const data = JSON.stringify({ 
      patterns: pM, 
      stats: { 
        w, l, bB, sB, cB, bS, wL, sPT, sPV, sPE, sPR, stage, level, 
        consecutiveWins, consecutiveLosses, paused, pauseHandCount, 
        predictionAccuracy, volatility, peakBankroll, lowestBankroll, 
        bankrollHistory, bettingStrategy, dLambertUnits, flatbetUnits, 
        andreiUnits, patternAge, markovMatrix, shoeStats 
      }
    });
    if (data.length > 5 * 1024 * 1024) {
      localStorage.clear();
    }
    await new Promise(resolve => setTimeout(resolve, 0));
    localStorage.setItem('baccaratPatterns', JSON.stringify(pM));
    localStorage.setItem('baccaratStats', JSON.stringify({ 
      w, l, bB, sB, cB, bS, wL, sPT, sPV, sPE, sPR, stage, level, 
      consecutiveWins, consecutiveLosses, paused, pauseHandCount, 
      predictionAccuracy, volatility, peakBankroll, lowestBankroll, 
      bankrollHistory, bettingStrategy, dLambertUnits, flatbetUnits, 
      andreiUnits, patternAge, markovMatrix, shoeStats 
    }));
  } catch (e) {
    return;
  }
}

async function loadMemory() {
  try {
    const patterns = localStorage.getItem('baccaratPatterns');
    const stats = localStorage.getItem('baccaratStats');
    if (patterns) {
      Object.assign(pM, JSON.parse(patterns));
    }
    if (stats) {
      const s = JSON.parse(stats);
      w = Number(s.w) || 0;
      l = Number(s.l) || 0;
      bB = Number(s.bB) || 0;
      sB = Number(s.sB) || 0;
      cB = Number(s.cB) || 0;
      sPT = s.sPT || 'percentage';
      sPV = Number(s.sPV) || 0;
      sPE = Number(s.sPE) || 0;
      sPR = s.sPR || false;
      bS = s.bS || { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
      stage = Number(s.stage) || 1;
      level = Number(s.level) || 0;
      consecutiveWins = Number(s.consecutiveWins) || 0;
      consecutiveLosses = Number(s.consecutiveLosses) || 0;
      paused = s.paused || false;
      pauseHandCount = Number(s.pauseHandCount) || 0;
      predictionAccuracy = s.predictionAccuracy || { correct: 0, total: 0 };
      volatility = Number(s.volatility) || 0;
      peakBankroll = Number(s.peakBankroll) || sB || 0;
      lowestBankroll = Number(s.lowestBankroll) || sB || Infinity;
      bankrollHistory.length = 0;
      bankrollHistory.push(...(Array.isArray(s.bankrollHistory) ? s.bankrollHistory : [sB]));
      Array.isArray(s.wL) && wL.push(...s.wL);
      bettingStrategy = s.bettingStrategy || 'mm';
      dLambertUnits = Number(s.dLambertUnits) || 1;
      flatbetUnits = Number(s.flatbetUnits) || 1;
      andreiUnits = Number(s.andreiUnits) || 1;
      patternAge = s.patternAge || {};
      markovMatrix = s.markovMatrix || {
        P: { P: 0, B: 0, T: 0, total: 0 },
        B: { P: 0, B: 0, T: 0, total: 0 },
        T: { P: 0, B: 0, T: 0, total: 0 }
      };
      shoeStats = s.shoeStats || {
        playerCount: 0,
        bankerCount: 0,
        tieCount: 0,
        longestPlayerStreak: 0,
        longestBankerStreak: 0,
        longestChoppy: 0
      };
      document.getElementById("stopProfitType").value = sPT;
      document.getElementById("stopProfitInput").value = sPV || '';
      document.getElementById("bettingStrategy").value = bettingStrategy;
      if (bettingStrategy === 'mm' && bB > 0) {
        betLevels = {
          stage1: [bB, bB * 2, bB * 3],
          stage2: [bB * 4, bB * 8],
          stage3: [bB * 1.4, bB, bB * 1.2, bB * 1.6, bB * 2]
        };
      }
    }
    updateDisplay();
  } catch (e) {
    localStorage.clear();
    w = l = 0;
    bB = sB = cB = 0;
    sPT = 'percentage';
    sPV = sPE = 0;
    sPR = false;
    bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    stage = 1;
    level = 0;
    consecutiveWins = 0;
    consecutiveLosses = 0;
    paused = false;
    pauseHandCount = 0;
    predictionAccuracy = { correct: 0, total: 0 };
    volatility = 0;
    peakBankroll = 0;
    lowestBankroll = Infinity;
    bankrollHistory.length = 0;
    bettingStrategy = 'mm';
    dLambertUnits = 1;
    flatbetUnits = 1;
    andreiUnits = 1;
    patternAge = {};
    markovMatrix = {
      P: { P: 0, B: 0, T: 0, total: 0 },
      B: { P: 0, B: 0, T: 0, total: 0 },
      T: { P: 0, B: 0, T: 0, total: 0 }
    };
    shoeStats = {
      playerCount: 0,
      bankerCount: 0,
      tieCount: 0,
      longestPlayerStreak: 0,
      longestBankerStreak: 0,
      longestChoppy: 0
    };
    document.getElementById("stopProfitType").value = sPT;
    document.getElementById("stopProfitInput").value = '';
    document.getElementById("bettingStrategy").value = bettingStrategy;
    updateDisplay();
  }
}

function resetStats() {
  try {
    if (!confirm("Reset stats?")) {
      return;
    }
    w = l = 0;
    cB = sB;
    sPT = 'percentage';
    sPV = 0;
    sPE = 0;
    sPR = false;
    paused = false;
    pauseHandCount = 0;
    if (bettingStrategy === 'mm') {
      stage = 1;
      level = 0;
      bS = { cBU: betLevels.stage1[0] / bB, tP: 0, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'dlambert') {
      dLambertUnits = 1;
      bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'flatbet') {
      flatbetUnits = 1;
      bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    } else if (bettingStrategy === 'andrei') {
      andreiUnits = 1;
      bS = { cBU: 1, tP: 0, cP: 0, previousLosses: [] };
    }
    consecutiveWins = 0;
    consecutiveLosses = 0;
    wL.length = 0;
    predictionAccuracy = { correct: 0, total: 0 };
    volatility = 0;
    peakBankroll = sB;
    lowestBankroll = sB;
    bankrollHistory.length = 0;
    bankrollHistory.push(sB);
    patternAge = {};
    markovMatrix = {
      P: { P: 0, B: 0, T: 0, total: 0 },
      B: { P: 0, B: 0, T: 0, total: 0 },
      T: { P: 0, B: 0, T: 0, total: 0 }
    };
    shoeStats = {
      playerCount: 0,
      bankerCount: 0,
      tieCount: 0,
      longestPlayerStreak: 0,
      longestBankerStreak: 0,
      longestChoppy: 0
    };
    document.getElementById("stopProfitType").value = sPT;
    document.getElementById("stopProfitInput").value = '';
    document.getElementById("bettingStrategy").value = bettingStrategy;
    updateDisplay();
  } catch (e) {
    return;
  }
}

function resetMemory() {
  try {
    if (!confirm("Reset patterns?")) {
      return;
    }
    for (let k in pM) delete pM[k];
    patternAge = {};
    markovMatrix = {
      P: { P: 0, B: 0, T: 0, total: 0 },
      B: { P: 0, B: 0, T: 0, total: 0 },
      T: { P: 0, B: 0, T: 0, total: 0 }
    };
    shoeStats = {
      playerCount: 0,
      bankerCount: 0,
      tieCount: 0,
      longestPlayerStreak: 0,
      longestBankerStreak: 0,
      longestChoppy: 0
    };
    updateDisplay();
    saveMemoryFast();
  } catch (e) {
    return;
  }
}

function startNewShoe() {
  try {
    if (!confirm("Start new shoe?")) {
      return;
    }
    if (document.getElementById("resetOnNewShoe").checked) {
      resetMemory();
    }
    r.length = 0;
    pH.length = 0;
    wL.length = 0;
    paused = false;
    pauseHandCount = 0;
    shoeStats = {
      playerCount: 0,
      bankerCount: 0,
      tieCount: 0,
      longestPlayerStreak: 0,
      longestBankerStreak: 0,
      longestChoppy: 0
    };
    updateDisplay();
  } catch (e) {
    return;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  try {
    loadMemory();
  } catch (e) {
    return;
  }
});
  </script>
</body>
</html>
